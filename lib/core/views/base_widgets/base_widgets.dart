// ignore_for_file: use_super_parameters

import 'dart:ui';

import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_form_builder/flutter_form_builder.dart';
import 'package:intl/intl.dart' show DateFormat;
import 'package:intl/intl.dart' show NumberFormat;

class ProContainer extends Container {
  // ignore: use_super_parameters
  ProContainer({
    Key? key,
    AlignmentGeometry? alignment,
    EdgeInsetsGeometry? padding =
        const EdgeInsets.symmetric(vertical: 2.0, horizontal: 2.0),
    Decoration? decoration,
    Decoration? foregroundDecoration,
    double? width,
    double? height,
    BoxConstraints? constraints,
    EdgeInsetsGeometry? margin = const EdgeInsets.all(10.0),
    Matrix4? transform,
    AlignmentGeometry? transformAlignment,
    Widget? child,
    Clip clipBehavior = Clip.none, required Color color,
  }) : super(
          key: key,
          alignment: alignment,
          padding: padding,
          decoration: decoration ??
              BoxDecoration(
                color: Colors.blue,
                borderRadius: BorderRadius.circular(10.0),
                boxShadow: [
                  BoxShadow(
                    color: Colors.grey.withOpacity(0.75),
                    spreadRadius: 2,
                    blurRadius: 2,
                    offset: const Offset(0, 0),
                  ),
                ],
              ),
          foregroundDecoration: foregroundDecoration,
          width: width,
          height: height,
          constraints: constraints,
          margin: margin,
          transform: transform,
          transformAlignment: transformAlignment,
          clipBehavior: clipBehavior,
          child: child,
        );
}

class ProColumn extends Column {
  // ignore: use_super_parameters
  const ProColumn({
    Key? key,
    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,
    MainAxisSize mainAxisSize = MainAxisSize.max,
    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,
    TextDirection? textDirection,
    VerticalDirection verticalDirection = VerticalDirection.down,
    TextBaseline? textBaseline,
    List<Widget> children = const [],
  }) : super(
          key: key,
          mainAxisAlignment: mainAxisAlignment,
          mainAxisSize: mainAxisSize,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          textBaseline: textBaseline,
          children: children,
        );
}

class ProRow extends Row {
  // ignore: use_super_parameters
  const ProRow({
    Key? key,
    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,
    MainAxisSize mainAxisSize = MainAxisSize.max,
    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,
    TextDirection? textDirection,
    VerticalDirection verticalDirection = VerticalDirection.down,
    TextBaseline? textBaseline,
    List<Widget> children = const <Widget>[],
  }) : super(
          key: key,
          mainAxisAlignment: mainAxisAlignment,
          mainAxisSize: mainAxisSize,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          textBaseline: textBaseline,
          children: children,
        );
}

class ProElevatedButton extends ElevatedButton {
  const ProElevatedButton({
    Key? key,
    required VoidCallback? onPressed,
    required Widget? child,
    VoidCallback? onLongPress,
    ButtonStyle? style,
    FocusNode? focusNode,
    bool autofocus = false,
    Clip clipBehavior = Clip.none,
  }) : super(
          key: key,
          onPressed: onPressed,
          onLongPress: onLongPress,
          style: style,
          focusNode: focusNode,
          autofocus: autofocus,
          clipBehavior: clipBehavior,
          child: child,
        );
}

class ProTextButton extends TextButton {
  // ignore: use_super_parameters
  const ProTextButton({
    Key? key,
    required VoidCallback? onPressed,
    required Widget child,
    VoidCallback? onLongPress,
    ButtonStyle? style,
    FocusNode? focusNode,
    bool autofocus = false,
    Clip clipBehavior = Clip.none,
    TextAlign textAlign = TextAlign.left,
    TextDirection textDirection = TextDirection.ltr,
  }) : super(
          key: key,
          onPressed: onPressed,
          onLongPress: onLongPress,
          style: style,
          focusNode: focusNode,
          autofocus: autofocus,
          clipBehavior: clipBehavior,
          child: child,
        );
}

class ProImage extends Image {
  const ProImage({
    Key? key,
    required ImageProvider<Object> image,
    Widget Function(BuildContext, Widget, int?, bool)? frameBuilder,
    Widget Function(BuildContext, Widget, ImageChunkEvent?)? loadingBuilder,
    Widget Function(BuildContext, Object, StackTrace?)? errorBuilder,
    String? semanticLabel,
    bool excludeFromSemantics = false,
    double? width,
    double? height,
    Color? color,
    Animation<double>? opacity,
    BlendMode? colorBlendMode,
    BoxFit? fit,
    AlignmentGeometry alignment = Alignment.center,
    ImageRepeat repeat = ImageRepeat.noRepeat,
    Rect? centerSlice,
    bool matchTextDirection = false,
    bool gaplessPlayback = false,
    bool isAntiAlias = false,
    FilterQuality filterQuality = FilterQuality.low,
  }) : super(
          key: key,
          image: image,
          frameBuilder: frameBuilder,
          loadingBuilder: loadingBuilder,
          errorBuilder: errorBuilder,
          semanticLabel: semanticLabel,
          excludeFromSemantics: excludeFromSemantics,
          width: width,
          height: height,
          color: color,
          opacity: opacity,
          colorBlendMode: colorBlendMode,
          fit: fit,
          alignment: alignment,
          repeat: repeat,
          centerSlice: centerSlice,
          matchTextDirection: matchTextDirection,
          gaplessPlayback: gaplessPlayback,
          isAntiAlias: isAntiAlias,
          filterQuality: filterQuality,
        );
}


 class ProIcon extends Icon {
  // ignore: use super parameters
  const ProIcon (
    IconData? icon,{
    Key? key,
    double? size,
    double? fill,
    double? weight,
    double? grade,
    double? opticalSize,
    Color? color,
    List<Shadow>? shadows,
    String? semanticLabel,
    TextDirection? textDirection,
    bool? applyTextScaling, 
   } ):super(
      icon,
      key: key,
      size: size,
      fill: fill,
      weight: weight,
      grade: grade,
      opticalSize: opticalSize,
      color: color,
      shadows: shadows,
      semanticLabel: semanticLabel,
      textDirection: textDirection,
      applyTextScaling: applyTextScaling,
    );
 }


 class ProIconButton extends IconButton{
    // ignore: use super parameters
   const  ProIconButton ({
     Key? key,
     double? iconSize,
     VisualDensity? visualDensity,
     EdgeInsetsGeometry? padding,
     AlignmentGeometry? alignment,
     double? splashRadius,
     Color? color,
     Color? focusColor,
     Color? hoverColor,
     Color? highlightColor,
     Color? splashColor,
     Color? disabledColor,
     required void Function()? onPressed,
     MouseCursor? mouseCursor,
     FocusNode? focusNode,
     bool autofocus = false,
     String? tooltip,
     bool? enableFeedback,
     BoxConstraints? constraints,
     ButtonStyle? style,
     bool? isSelected,
     Widget? selectedIcon,
     required Widget icon,
     
    }): super(
          key: key,
          iconSize: iconSize,
          visualDensity: visualDensity,
          padding: padding ?? const EdgeInsets.all(8.0),
          alignment: alignment,
          splashRadius: splashRadius,
          color: color,
          focusColor: focusColor,
          hoverColor: hoverColor,
          highlightColor: highlightColor,
          splashColor: splashColor,
          disabledColor: disabledColor,
          onPressed: onPressed,
          mouseCursor: mouseCursor,
          focusNode: focusNode,
          autofocus: autofocus,
          tooltip: tooltip,
          enableFeedback: enableFeedback ?? true,
          constraints: constraints,
          icon: icon,
        );
 } 

class ProText extends Text {
  // ignore: use_super_parameters
  const ProText(
    dynamic data, {
    Key? key,
    TextStyle? style,
    StrutStyle? strutStyle,
    TextAlign? textAlign,
    TextDirection? textDirection,
    Locale? locale,
    bool? softWrap,
    TextOverflow? overflow,
    int? maxLines,
    String? semanticsLabel,
    TextWidthBasis? textWidthBasis,
    TextHeightBehavior? textHeightBehavior,
    Color? selectionColor,
  }) : super(
          data,
          key: key,
          style: style,
          strutStyle: strutStyle,
          textAlign: textAlign,
          textDirection: textDirection,
          locale: locale,
          softWrap: softWrap,
          overflow: overflow,
          maxLines: maxLines,
          semanticsLabel: semanticsLabel,
          textWidthBasis: textWidthBasis,
          textHeightBehavior: textHeightBehavior,
          selectionColor: selectionColor,
        );
}

class ProTextField extends FormBuilderTextField {
  ProTextField({
    Key? key,
    required String name,
    String? Function(String?)? validator,
    InputDecoration decoration = const InputDecoration(),
    void Function(String?)? onChanged,
    dynamic Function(String?)? valueTransformer,
    bool enabled = true,
    void Function(String?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    String? initialValue,
    bool readOnly = false,
    int? maxLines = 1,
    bool obscureText = false,
    TextCapitalization textCapitalization = TextCapitalization.none,
    EdgeInsets scrollPadding = const EdgeInsets.all(20.0),
    bool enableInteractiveSelection = true,
    MaxLengthEnforcement? maxLengthEnforcement,
    TextAlign textAlign = TextAlign.start,
    bool autofocus = false,
    bool autocorrect = true,
    double cursorWidth = 2.0,
    double? cursorHeight,
    TextInputType? keyboardType,
    TextStyle? style,
    TextEditingController? controller,
    TextInputAction? textInputAction,
    StrutStyle? strutStyle,
    TextDirection? textDirection,
    int? maxLength,
    void Function()? onEditingComplete,
    void Function(String?)? onSubmitted,
    List<TextInputFormatter>? inputFormatters,
    Radius? cursorRadius,
    Color? cursorColor,
    Brightness? keyboardAppearance,
    Widget Function(BuildContext,
            {required int currentLength,
            required bool isFocused,
            required int? maxLength})?
        buildCounter,
    bool expands = false,
    int? minLines,
    bool? showCursor,
    void Function()? onTap,
    void Function(PointerDownEvent)? onTapOutside,
    bool enableSuggestions = false,
    TextAlignVertical? textAlignVertical,
    DragStartBehavior dragStartBehavior = DragStartBehavior.start,
    ScrollController? scrollController,
    ScrollPhysics? scrollPhysics,
    BoxWidthStyle selectionWidthStyle = BoxWidthStyle.tight,
    SmartDashesType? smartDashesType,
    SmartQuotesType? smartQuotesType,
    BoxHeightStyle selectionHeightStyle = BoxHeightStyle.tight,
    Iterable<String>? autofillHints,
    String obscuringCharacter = 'â€¢',
    MouseCursor? mouseCursor,
    Widget Function(BuildContext, EditableTextState)? contextMenuBuilder,
    TextMagnifierConfiguration? magnifierConfiguration,
    ContentInsertionConfiguration? contentInsertionConfiguration,
    SpellCheckConfiguration? spellCheckConfiguration,
  }) : super(
          key: key,
          name: name,
          validator: validator,
          decoration: decoration,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          enabled: enabled,
          onSaved: onSaved,
          autovalidateMode: autovalidateMode,
          onReset: onReset,
          focusNode: focusNode,
          restorationId: restorationId,
          initialValue: initialValue,
          readOnly: readOnly,
          maxLines: maxLines,
          obscureText: obscureText,
          textCapitalization: textCapitalization,
          scrollPadding: scrollPadding,
          enableInteractiveSelection: enableInteractiveSelection,
          maxLengthEnforcement: maxLengthEnforcement,
          textAlign: textAlign,
          autofocus: autofocus,
          autocorrect: autocorrect,
          cursorWidth: cursorWidth,
          cursorHeight: cursorHeight,
          keyboardType: keyboardType,
          style: style,
          controller: controller,
          textInputAction: textInputAction,
          strutStyle: strutStyle,
          textDirection: textDirection,
          maxLength: maxLength,
          onEditingComplete: onEditingComplete,
          onSubmitted: onSubmitted,
          inputFormatters: inputFormatters,
          cursorRadius: cursorRadius,
          cursorColor: cursorColor,
          keyboardAppearance: keyboardAppearance,
          buildCounter: buildCounter,
          expands: expands,
          minLines: minLines,
          showCursor: showCursor,
          onTap: onTap,
          onTapOutside: onTapOutside,
          enableSuggestions: enableSuggestions,
          textAlignVertical: textAlignVertical,
          dragStartBehavior: dragStartBehavior,
          scrollController: scrollController,
          scrollPhysics: scrollPhysics,
          selectionWidthStyle: selectionWidthStyle,
          smartDashesType: smartDashesType,
          smartQuotesType: smartQuotesType,
          selectionHeightStyle: selectionHeightStyle,
          autofillHints: autofillHints,
          obscuringCharacter: obscuringCharacter,
          mouseCursor: mouseCursor,
          contextMenuBuilder: contextMenuBuilder,
          magnifierConfiguration: magnifierConfiguration,
          contentInsertionConfiguration: contentInsertionConfiguration,
          spellCheckConfiguration: spellCheckConfiguration,
        );
}

class ProGridView extends GridView {
  // ignore: use_super_parameters
  ProGridView({
    Key? key,
    Axis scrollDirection = Axis.vertical,
    bool reverse = false,
    ScrollController? controller,
    bool? primary,
    ScrollPhysics? physics,
    bool shrinkWrap = false,
    EdgeInsetsGeometry? padding,
    required SliverGridDelegate gridDelegate,
    bool addAutomaticKeepAlives = true,
    bool addRepaintBoundaries = true,
    bool addSemanticIndexes = true,
    double? cacheExtent,
    List<Widget> children = const <Widget>[],
    int? semanticChildCount,
    Clip clipBehavior = Clip.hardEdge,
    ScrollViewKeyboardDismissBehavior keyboardDismissBehavior =
        ScrollViewKeyboardDismissBehavior.manual,
  }) : super(
          key: key,
          scrollDirection: scrollDirection,
          reverse: reverse,
          controller: controller,
          primary: primary,
          physics: physics,
          shrinkWrap: shrinkWrap,
          padding: padding,
          gridDelegate: gridDelegate,
          addAutomaticKeepAlives: addAutomaticKeepAlives,
          addRepaintBoundaries: addRepaintBoundaries,
          addSemanticIndexes: addSemanticIndexes,
          cacheExtent: cacheExtent,
          semanticChildCount: semanticChildCount,
          clipBehavior: clipBehavior,
          keyboardDismissBehavior: keyboardDismissBehavior,
          children: children,
        );
}
 
class ProGridViewBuilder extends GridView {
   // ignore: use_super_parameters
  ProGridViewBuilder({
    Key? key,
    Axis scrollDirection = Axis.vertical,
    bool reverse = false,
    ScrollController? controller,
    bool? primary,
    ScrollPhysics? physics,
    bool shrinkWrap = false,
    EdgeInsetsGeometry? padding,
    required SliverGridDelegate gridDelegate,
    required Widget Function(BuildContext, int) itemBuilder,
    int? Function(Key)? findChildIndexCallback,
    int? itemCount,
    bool addAutomaticKeepAlives = true,
    bool addRepaintBoundaries = true,
    bool addSemanticIndexes = true,
    double? cacheExtent,
    int? semanticChildCount,
    DragStartBehavior dragStartBehavior = DragStartBehavior.start,
    ScrollViewKeyboardDismissBehavior keyboardDismissBehavior =
        ScrollViewKeyboardDismissBehavior.manual,
    String? restorationId,
    Clip clipBehavior = Clip.hardEdge,
  }) : super(
          key: key,
          scrollDirection: scrollDirection,
          reverse: reverse,
          controller: controller,
          primary: primary,
          physics: physics,
          shrinkWrap: shrinkWrap,
          padding: padding,
          gridDelegate: gridDelegate,
         // itemBuilder: itemBuilder,
        //  findChildIndexCallback: findChildIndexCallback,
         // itemCount: itemCount,
          addAutomaticKeepAlives: addAutomaticKeepAlives,
          addRepaintBoundaries: addRepaintBoundaries,
          addSemanticIndexes: addSemanticIndexes,
          cacheExtent: cacheExtent,
          semanticChildCount: semanticChildCount,
          dragStartBehavior: dragStartBehavior,
          keyboardDismissBehavior: keyboardDismissBehavior,
          restorationId: restorationId,
          clipBehavior: clipBehavior,
        );
}


class ProTable extends Table {
  // ignore: use_super_parameters
  ProTable({
    Key? key,
    required List<List<String>> data,
    required int columnCount,
    Map<int, TableColumnWidth>? columnWidths,
    TableBorder? border,
    TableCellVerticalAlignment defaultVerticalAlignment =
        TableCellVerticalAlignment.middle,
    TextStyle? headerStyle,
    TextStyle? cellStyle,
    EdgeInsetsGeometry? cellPadding,
    AlignmentGeometry? cellAlignment,
  }) : super(
          key: key,
          border: border ?? TableBorder.all(),
          columnWidths: columnWidths,
          defaultVerticalAlignment: defaultVerticalAlignment,
          children: List<TableRow>.generate(
            data.length,
            (rowIndex) {
              return TableRow(
                children: List<Widget>.generate(
                  columnCount,
                  (colIndex) {
                    bool isHeader = rowIndex == 0;
                    return Padding(
                      padding: cellPadding ?? const EdgeInsets.all(8.0),
                      child: Align(
                        alignment: cellAlignment ?? Alignment.center,
                        child: Text(
                          data[rowIndex][colIndex],
                          style: isHeader ? headerStyle : cellStyle,
                        ),
                      ),
                    );
                  },
                ),
              );
            },
          ),
        );
}

class ProLinearProgressIndicator extends LinearProgressIndicator {
  // ignore: use_super_parameters
  const ProLinearProgressIndicator({
    Key? key,
    double? value,
    Color? backgroundColor,
    Color? color,
    Animation<Color?>? valueColor,
    double? minHeight,
    String? semanticsLabel,
    String? semanticsValue,
    BorderRadiusGeometry borderRadius = BorderRadius.zero,
  }) : super(
          key: key,
          value: value,
          backgroundColor: backgroundColor,
          color: color,
          valueColor: valueColor,
          minHeight: minHeight,
          semanticsLabel: semanticsLabel,
          semanticsValue: semanticsValue,
          borderRadius: borderRadius,
        );
}

class ProCheckbox extends FormBuilderCheckbox {
  // ignore: use_super_parameters
  ProCheckbox({
    Key? key,
    required String name,
    String? Function(bool?)? validator,
    bool? initialValue,
    InputDecoration decoration = const InputDecoration(
      border: InputBorder.none,
      focusedBorder: InputBorder.none,
      enabledBorder: InputBorder.none,
      errorBorder: InputBorder.none,
      disabledBorder: InputBorder.none,
    ),
    void Function(bool?)? onChanged,
    dynamic Function(bool?)? valueTransformer,
    bool enabled = true,
    void Function(bool?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    required Widget title,
    Color? activeColor,
    bool autofocus = false,
    Color? checkColor,
    EdgeInsets contentPadding = EdgeInsets.zero,
    VisualDensity? visualDensity,
    ListTileControlAffinity controlAffinity = ListTileControlAffinity.leading,
    Widget? secondary,
    bool selected = false,
    Widget? subtitle,
    bool tristate = false,
    OutlinedBorder? shape,
    BorderSide? side,
  }) : super(
          key: key,
          name: name,
          validator: validator,
          initialValue: initialValue,
          decoration: decoration,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          enabled: enabled,
          onSaved: onSaved,
          autovalidateMode: autovalidateMode,
          onReset: onReset,
          focusNode: focusNode,
          restorationId: restorationId,
          title: title,
          activeColor: activeColor,
          autofocus: autofocus,
          checkColor: checkColor,
          contentPadding: contentPadding,
          visualDensity: visualDensity,
          controlAffinity: controlAffinity,
          secondary: secondary,
          selected: selected,
          subtitle: subtitle,
          tristate: tristate,
          shape: shape,
          side: side,
        );
}

class ProCheckboxGroup extends FormBuilderCheckboxGroup {
  // ignore: use_super_parameters
  ProCheckboxGroup({
    Key? key,
    required String name,
    VisualDensity? visualDensity,
    String? Function(List<dynamic>?)? validator,
    List<dynamic>? initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(List<dynamic>?)? onChanged,
    dynamic Function(List<dynamic>?)? valueTransformer,
    bool enabled = true,
    void Function(List<dynamic>?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    required List<FormBuilderFieldOption<dynamic>> options,
    Color? activeColor,
    Color? checkColor,
    Color? focusColor,
    Color? hoverColor,
    List<dynamic>? disabled,
    MaterialTapTargetSize? materialTapTargetSize,
    bool tristate = false,
    Axis wrapDirection = Axis.horizontal,
    WrapAlignment wrapAlignment = WrapAlignment.start,
    double wrapSpacing = 0.0,
    WrapAlignment wrapRunAlignment = WrapAlignment.start,
    double wrapRunSpacing = 0.0,
    WrapCrossAlignment wrapCrossAxisAlignment = WrapCrossAlignment.start,
    TextDirection? wrapTextDirection,
    VerticalDirection wrapVerticalDirection = VerticalDirection.down,
    Widget? separator,
    ControlAffinity controlAffinity = ControlAffinity.leading,
    OptionsOrientation orientation = OptionsOrientation.wrap,
    BoxDecoration? itemDecoration,
  }) : super(
          key: key,
          name: name,
          visualDensity: visualDensity,
          validator: validator,
          initialValue: initialValue,
          decoration: decoration,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          enabled: enabled,
          onSaved: onSaved,
          autovalidateMode: autovalidateMode,
          onReset: onReset,
          focusNode: focusNode,
          restorationId: restorationId,
          options: options,
          activeColor: activeColor,
          checkColor: checkColor,
          focusColor: focusColor,
          hoverColor: hoverColor,
          disabled: disabled,
          materialTapTargetSize: materialTapTargetSize,
          tristate: tristate,
          wrapDirection: wrapDirection,
          wrapAlignment: wrapAlignment,
          wrapSpacing: wrapSpacing,
          wrapRunAlignment: wrapRunAlignment,
          wrapRunSpacing: wrapRunSpacing,
          wrapCrossAxisAlignment: wrapCrossAxisAlignment,
          wrapTextDirection: wrapTextDirection,
          wrapVerticalDirection: wrapVerticalDirection,
          separator: separator,
          controlAffinity: controlAffinity,
          orientation: orientation,
          itemDecoration: itemDecoration,
        );
}

class ProChoiceChip extends FormBuilderChoiceChip<dynamic> {
  // ignore: use_super_parameters
  ProChoiceChip({
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    bool enabled = true,
    FocusNode? focusNode,
    void Function(dynamic)? onSaved,
    String? Function(dynamic)? validator,
    InputDecoration decoration = const InputDecoration(),
    Key? key,
    required String name,
    required List<FormBuilderChipOption<dynamic>> options,
    dynamic initialValue,
    String? restorationId,
    void Function(dynamic)? onChanged,
    dynamic Function(dynamic)? valueTransformer,
    void Function()? onReset,
    WrapAlignment alignment = WrapAlignment.start,
    ShapeBorder avatarBorder = const CircleBorder(),
    Color? backgroundColor,
    WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start,
    Axis direction = Axis.horizontal,
    Color? disabledColor,
    double? elevation,
    EdgeInsets? labelPadding,
    TextStyle? labelStyle,
    MaterialTapTargetSize? materialTapTargetSize,
    EdgeInsets? padding,
    double? pressElevation,
    WrapAlignment runAlignment = WrapAlignment.start,
    double runSpacing = 0.0,
    Color? selectedColor,
    Color? selectedShadowColor,
    Color? shadowColor,
    OutlinedBorder? shape,
    double spacing = 0.0,
    TextDirection? textDirection,
    VerticalDirection verticalDirection = VerticalDirection.down,
    VisualDensity? visualDensity,
  }) : super(
          autovalidateMode: autovalidateMode,
          enabled: enabled,
          focusNode: focusNode,
          onSaved: onSaved,
          validator: validator,
          decoration: decoration,
          key: key,
          name: name,
          options: options,
          initialValue: initialValue,
          restorationId: restorationId,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          onReset: onReset,
          alignment: alignment,
          avatarBorder: avatarBorder,
          backgroundColor: backgroundColor,
          crossAxisAlignment: crossAxisAlignment,
          direction: direction,
          disabledColor: disabledColor,
          elevation: elevation,
          labelPadding: labelPadding,
          labelStyle: labelStyle,
          materialTapTargetSize: materialTapTargetSize,
          padding: padding,
          pressElevation: pressElevation,
          runAlignment: runAlignment,
          runSpacing: runSpacing,
          selectedColor: selectedColor,
          selectedShadowColor: selectedShadowColor,
          shadowColor: shadowColor,
          shape: shape,
          spacing: spacing,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          visualDensity: visualDensity,
        );
}

class ProDateRangePicker extends FormBuilderDateRangePicker {
  // ignore: use_super_parameters
  ProDateRangePicker({
    Key? key,
    required String name,
    String? Function(DateTimeRange?)? validator,
    DateTimeRange? initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(DateTimeRange?)? onChanged,
    dynamic Function(DateTimeRange?)? valueTransformer,
    bool enabled = true,
    void Function(DateTimeRange?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    required DateTime firstDate,
    required DateTime lastDate,
    DateFormat? format,
    int maxLines = 1,
    bool obscureText = false,
    TextCapitalization textCapitalization = TextCapitalization.none,
    EdgeInsets scrollPadding = const EdgeInsets.all(20.0),
    bool enableInteractiveSelection = true,
    MaxLengthEnforcement? maxLengthEnforcement,
    TextAlign textAlign = TextAlign.start,
    TextAlignVertical? textAlignVertical,
    bool autofocus = false,
    bool autocorrect = true,
    double cursorWidth = 2.0,
    TextInputType? keyboardType,
    TextStyle? style,
    TextEditingController? controller,
    TextInputAction? textInputAction,
    StrutStyle? strutStyle,
    TextDirection? textDirection,
    int? maxLength,
    void Function()? onEditingComplete,
    void Function(DateTimeRange?)? onFieldSubmitted,
    List<TextInputFormatter>? inputFormatters,
    Radius? cursorRadius,
    Color? cursorColor,
    Brightness? keyboardAppearance,
    Widget? Function(BuildContext,
            {required int currentLength,
            required bool isFocused,
            required int? maxLength})?
        buildCounter,
    MouseCursor? mouseCursor,
    bool expands = false,
    int? minLines,
    bool showCursor = false,
    Locale? locale,
    String? cancelText,
    String? confirmText,
    DateTime? currentDate,
    String? errorFormatText,
    Widget Function(BuildContext, Widget?)? pickerBuilder,
    String? errorInvalidRangeText,
    String? errorInvalidText,
    String? fieldEndHintText,
    String? fieldEndLabelText,
    String? fieldStartHintText,
    String? fieldStartLabelText,
    String? helpText,
    DatePickerEntryMode initialEntryMode = DatePickerEntryMode.calendar,
    RouteSettings? routeSettings,
    String? saveText,
    bool useRootNavigator = true,
    bool allowClear = false,
    Widget? clearIcon,
  }) : super(
          key: key,
          name: name,
          validator: validator,
          initialValue: initialValue,
          decoration: decoration,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          enabled: enabled,
          onSaved: onSaved,
          autovalidateMode: autovalidateMode,
          onReset: onReset,
          focusNode: focusNode,
          restorationId: restorationId,
          firstDate: firstDate,
          lastDate: lastDate,
          format: format,
          maxLines: maxLines,
          obscureText: obscureText,
          textCapitalization: textCapitalization,
          scrollPadding: scrollPadding,
          enableInteractiveSelection: enableInteractiveSelection,
          maxLengthEnforcement: maxLengthEnforcement,
          textAlign: textAlign,
          textAlignVertical: textAlignVertical,
          autofocus: autofocus,
          autocorrect: autocorrect,
          cursorWidth: cursorWidth,
          keyboardType: keyboardType,
          style: style,
          controller: controller,
          textInputAction: textInputAction,
          strutStyle: strutStyle,
          textDirection: textDirection,
          maxLength: maxLength,
          onEditingComplete: onEditingComplete,
          onFieldSubmitted: onFieldSubmitted,
          inputFormatters: inputFormatters,
          cursorRadius: cursorRadius,
          cursorColor: cursorColor,
          keyboardAppearance: keyboardAppearance,
          buildCounter: buildCounter,
          mouseCursor: mouseCursor,
          expands: expands,
          minLines: minLines,
          showCursor: showCursor,
          locale: locale,
          cancelText: cancelText,
          confirmText: confirmText,
          currentDate: currentDate,
          errorFormatText: errorFormatText,
          pickerBuilder: pickerBuilder,
          errorInvalidRangeText: errorInvalidRangeText,
          errorInvalidText: errorInvalidText,
          fieldEndHintText: fieldEndHintText,
          fieldEndLabelText: fieldEndLabelText,
          fieldStartHintText: fieldStartHintText,
          fieldStartLabelText: fieldStartLabelText,
          helpText: helpText,
          initialEntryMode: initialEntryMode,
          routeSettings: routeSettings,
          saveText: saveText,
          useRootNavigator: useRootNavigator,
          allowClear: allowClear,
          clearIcon: clearIcon,
        );
}

class ProDateTimePicker extends FormBuilderDateTimePicker {
  // ignore: use_super_parameters
  ProDateTimePicker({
    Key? key,
    required String name,
    String? Function(DateTime?)? validator,
    DateTime? initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(DateTime?)? onChanged,
    dynamic Function(DateTime?)? valueTransformer,
    bool enabled = true,
    void Function(DateTime?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    InputType inputType = InputType.both,
    EdgeInsets scrollPadding = const EdgeInsets.all(20.0),
    double cursorWidth = 2.0,
    bool enableInteractiveSelection = true,
    Widget? resetIcon = const Icon(Icons.close),
    TimeOfDay initialTime = const TimeOfDay(hour: 12, minute: 0),
    TextInputType? keyboardType,
    TextAlign textAlign = TextAlign.start,
    bool autofocus = false,
    bool obscureText = false,
    bool autocorrect = true,
    int? maxLines = 1,
    bool expands = false,
    DatePickerMode initialDatePickerMode = DatePickerMode.day,
    Widget Function(BuildContext, Widget?)? transitionBuilder,
    TextCapitalization textCapitalization = TextCapitalization.none,
    bool useRootNavigator = true,
    DatePickerEntryMode initialEntryMode = DatePickerEntryMode.calendar,
    TimePickerEntryMode timePickerInitialEntryMode = TimePickerEntryMode.dial,
    DateFormat? format,
    DateTime? initialDate,
    DateTime? firstDate,
    DateTime? lastDate,
    DateTime? currentDate,
    Locale? locale,
    int? maxLength,
    TextDirection? textDirection,
    TextAlignVertical? textAlignVertical,
    void Function(DateTime?)? onFieldSubmitted,
    TextEditingController? controller,
    TextStyle? style,
    MaxLengthEnforcement maxLengthEnforcement = MaxLengthEnforcement.none,
    List<TextInputFormatter>? inputFormatters,
    bool showCursor = false,
    int? minLines,
    TextInputAction? textInputAction,
    void Function()? onEditingComplete,
    Widget? Function(BuildContext,
            {required int currentLength,
            required bool isFocused,
            required int? maxLength})?
        buildCounter,
    MouseCursor? mouseCursor,
    Radius? cursorRadius,
    Color? cursorColor,
    Brightness? keyboardAppearance,
    String? cancelText,
    String? confirmText,
    String? errorFormatText,
    String? errorInvalidText,
    String? fieldHintText,
    String? fieldLabelText,
    String? helpText,
    RouteSettings? routeSettings,
    StrutStyle? strutStyle,
    bool Function(DateTime)? selectableDayPredicate,
    Offset? anchorPoint,
    void Function(TimePickerEntryMode)? onEntryModeChanged, required EdgeInsets margin, required ProText child,
  }) : super(
          key: key,
          name: name,
          validator: validator,
          initialValue: initialValue,
          decoration: decoration,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          enabled: enabled,
          onSaved: onSaved,
          autovalidateMode: autovalidateMode,
          onReset: onReset,
          focusNode: focusNode,
          restorationId: restorationId,
          inputType: inputType,
          scrollPadding: scrollPadding,
          cursorWidth: cursorWidth,
          enableInteractiveSelection: enableInteractiveSelection,
          resetIcon: resetIcon,
          initialTime: initialTime,
          keyboardType: keyboardType,
          textAlign: textAlign,
          autofocus: autofocus,
          obscureText: obscureText,
          maxLines: maxLines,
          expands: expands,
          initialDatePickerMode: initialDatePickerMode,
          transitionBuilder: transitionBuilder,
          textCapitalization: textCapitalization,
          useRootNavigator: useRootNavigator,
          initialEntryMode: initialEntryMode,
          timePickerInitialEntryMode: timePickerInitialEntryMode,
          format: format,
          initialDate: initialDate,
          firstDate: firstDate,
          lastDate: lastDate,
          currentDate: currentDate,
          locale: locale,
          maxLength: maxLength,
          textDirection: textDirection,
          textAlignVertical: textAlignVertical,
          onFieldSubmitted: onFieldSubmitted,
          controller: controller,
          style: style,
          maxLengthEnforcement: maxLengthEnforcement,
          inputFormatters: inputFormatters,
          showCursor: showCursor,
          minLines: minLines,
          textInputAction: textInputAction,
          onEditingComplete: onEditingComplete,
          buildCounter: buildCounter,
          mouseCursor: mouseCursor,
          cursorRadius: cursorRadius,
          cursorColor: cursorColor,
          keyboardAppearance: keyboardAppearance,
          cancelText: cancelText,
          confirmText: confirmText,
          errorFormatText: errorFormatText,
          errorInvalidText: errorInvalidText,
          fieldHintText: fieldHintText,
          fieldLabelText: fieldLabelText,
          helpText: helpText,
          routeSettings: routeSettings,
          strutStyle: strutStyle,
          selectableDayPredicate: selectableDayPredicate,
          anchorPoint: anchorPoint,
          onEntryModeChanged: onEntryModeChanged,
        );
}

class ProDropdown extends FormBuilderDropdown {
  // ignore: use_super_parameters
  ProDropdown({
    Key? key,
    required String name,
    String? Function(dynamic)? validator,
    dynamic initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(dynamic)? onChanged,
    dynamic Function(dynamic)? valueTransformer,
    bool enabled = true,
    void Function(dynamic)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    required List<DropdownMenuItem<dynamic>> items,
    bool isExpanded = true,
    bool isDense = true,
    int elevation = 8,
    double iconSize = 24.0,
    TextStyle? style,
    Widget? disabledHint,
    Widget? icon,
    Color? iconDisabledColor,
    Color? iconEnabledColor,
    void Function()? onTap,
    bool autofocus = false,
    Color? dropdownColor,
    Color? focusColor,
    double? itemHeight,
    List<Widget> Function(BuildContext)? selectedItemBuilder,
    double? menuMaxHeight,
    bool? enableFeedback,
    BorderRadius? borderRadius,
    AlignmentGeometry alignment = AlignmentDirectional.centerStart,
  }) : super(
          key: key,
          name: name,
          validator: validator,
          initialValue: initialValue,
          decoration: decoration,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          enabled: enabled,
          onSaved: onSaved,
          autovalidateMode: autovalidateMode,
          onReset: onReset,
          focusNode: focusNode,
          restorationId: restorationId,
          items: items,
          isExpanded: isExpanded,
          isDense: isDense,
          elevation: elevation,
          iconSize: iconSize,
          style: style,
          disabledHint: disabledHint,
          icon: icon,
          iconDisabledColor: iconDisabledColor,
          iconEnabledColor: iconEnabledColor,
          onTap: onTap,
          autofocus: autofocus,
          dropdownColor: dropdownColor,
          focusColor: focusColor,
          itemHeight: itemHeight,
          selectedItemBuilder: selectedItemBuilder,
          menuMaxHeight: menuMaxHeight,
          enableFeedback: enableFeedback,
          borderRadius: borderRadius,
          alignment: alignment,
        );
}

class ProFilterChip extends FormBuilderFilterChip {
  // ignore: use_super_parameters
  ProFilterChip({
    Key? key,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    bool enabled = true,
    FocusNode? focusNode,
    void Function(List<dynamic>?)? onSaved,
    String? Function(List<dynamic>?)? validator,
    InputDecoration decoration = const InputDecoration(),
    List<dynamic>? initialValue,
    required String name,
    String? restorationId,
    required List<FormBuilderChipOption<dynamic>> options,
    WrapAlignment alignment = WrapAlignment.start,
    ShapeBorder avatarBorder = const CircleBorder(),
    Color? backgroundColor,
    Color? checkmarkColor,
    Clip clipBehavior = Clip.none,
    WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start,
    Axis direction = Axis.horizontal,
    Color? disabledColor,
    double? elevation,
    EdgeInsets? labelPadding,
    TextStyle? labelStyle,
    MaterialTapTargetSize? materialTapTargetSize,
    int? maxChips,
    EdgeInsets? padding,
    double? pressElevation,
    WrapAlignment runAlignment = WrapAlignment.start,
    double runSpacing = 0.0,
    Color? selectedColor,
    Color? selectedShadowColor,
    Color? shadowColor,
    OutlinedBorder? shape,
    bool showCheckmark = true,
    double spacing = 0.0,
    TextDirection? textDirection,
    VerticalDirection verticalDirection = VerticalDirection.down,
    void Function(List<dynamic>?)? onChanged,
    dynamic Function(List<dynamic>?)? valueTransformer,
    void Function()? onReset,
  }) : super(
          key: key,
          autovalidateMode: autovalidateMode,
          enabled: enabled,
          focusNode: focusNode,
          onSaved: onSaved,
          validator: validator,
          decoration: decoration,
          initialValue: initialValue,
          name: name,
          restorationId: restorationId,
          options: options,
          alignment: alignment,
          avatarBorder: avatarBorder,
          backgroundColor: backgroundColor,
          checkmarkColor: checkmarkColor,
          clipBehavior: clipBehavior,
          crossAxisAlignment: crossAxisAlignment,
          direction: direction,
          disabledColor: disabledColor,
          elevation: elevation,
          labelPadding: labelPadding,
          labelStyle: labelStyle,
          materialTapTargetSize: materialTapTargetSize,
          maxChips: maxChips,
          padding: padding,
          pressElevation: pressElevation,
          runAlignment: runAlignment,
          runSpacing: runSpacing,
          selectedColor: selectedColor,
          selectedShadowColor: selectedShadowColor,
          shadowColor: shadowColor,
          shape: shape,
          showCheckmark: showCheckmark,
          spacing: spacing,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          onReset: onReset,
        );
}

class ProRadioGroup extends FormBuilderRadioGroup<dynamic> {
  ProRadioGroup({
    Key? key,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    bool enabled = true,
    FocusNode? focusNode,
    void Function(dynamic)? onSaved,
    String? Function(dynamic)? validator,
    InputDecoration decoration = const InputDecoration(),
    required String name,
    required List<FormBuilderFieldOption<dynamic>> options,
    dynamic initialValue,
    Color? activeColor,
    ControlAffinity controlAffinity = ControlAffinity.leading,
    List<dynamic>? disabled,
    Color? focusColor,
    Color? hoverColor,
    MaterialTapTargetSize? materialTapTargetSize,
    OptionsOrientation orientation = OptionsOrientation.wrap,
    Widget? separator,
    WrapAlignment wrapAlignment = WrapAlignment.start,
    WrapCrossAlignment wrapCrossAxisAlignment = WrapCrossAlignment.start,
    Axis wrapDirection = Axis.horizontal,
    WrapAlignment wrapRunAlignment = WrapAlignment.start,
    double wrapRunSpacing = 0.0,
    double wrapSpacing = 0.0,
    TextDirection? wrapTextDirection,
    VerticalDirection wrapVerticalDirection = VerticalDirection.down,
    void Function(dynamic)? onChanged,
    dynamic Function(dynamic)? valueTransformer,
    void Function()? onReset,
    String? restorationId,
    BoxDecoration? itemDecoration,
  }) : super(
          key: key,
          autovalidateMode: autovalidateMode,
          enabled: enabled,
          focusNode: focusNode,
          onSaved: onSaved,
          validator: validator,
          decoration: decoration,
          name: name,
          options: options,
          initialValue: initialValue,
          activeColor: activeColor,
          controlAffinity: controlAffinity,
          disabled: disabled,
          focusColor: focusColor,
          hoverColor: hoverColor,
          materialTapTargetSize: materialTapTargetSize,
          orientation: orientation,
          separator: separator,
          wrapAlignment: wrapAlignment,
          wrapCrossAxisAlignment: wrapCrossAxisAlignment,
          wrapDirection: wrapDirection,
          wrapRunAlignment: wrapRunAlignment,
          wrapRunSpacing: wrapRunSpacing,
          wrapSpacing: wrapSpacing,
          wrapTextDirection: wrapTextDirection,
          wrapVerticalDirection: wrapVerticalDirection,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          onReset: onReset,
          restorationId: restorationId,
          itemDecoration: itemDecoration,
        );
}

class ProRangeSlider extends FormBuilderRangeSlider {
  // ignore: use_super_parameters
  ProRangeSlider({
    Key? key,
    required String name,
    String? Function(RangeValues?)? validator,
    RangeValues? initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(RangeValues?)? onChanged,
    dynamic Function(RangeValues?)? valueTransformer,
    bool enabled = true,
    void Function(RangeValues?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    required double min,
    required double max,
    int? divisions,
    Color? activeColor,
    Color? inactiveColor,
    void Function(RangeValues)? onChangeStart,
    void Function(RangeValues)? onChangeEnd,
    RangeLabels? labels,
    String Function(double)? semanticFormatterCallback,
    DisplayValues displayValues = DisplayValues.all,
    Widget Function(String)? minValueWidget,
    Widget Function(String)? valueWidget,
    Widget Function(String)? maxValueWidget,
    NumberFormat? numberFormat,
  }) : super(
          key: key,
          name: name,
          validator: validator,
          initialValue: initialValue,
          decoration: decoration,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          enabled: enabled,
          onSaved: onSaved,
          autovalidateMode: autovalidateMode,
          onReset: onReset,
          focusNode: focusNode,
          min: min,
          max: max,
          divisions: divisions,
          activeColor: activeColor,
          inactiveColor: inactiveColor,
          onChangeStart: onChangeStart,
          onChangeEnd: onChangeEnd,
          labels: labels,
          semanticFormatterCallback: semanticFormatterCallback,
          displayValues: displayValues,
          minValueWidget: minValueWidget,
          valueWidget: valueWidget,
          maxValueWidget: maxValueWidget,
          numberFormat: numberFormat,
        );
}

class ProSlider extends FormBuilderSlider {
  // ignore: use_super_parameters
  ProSlider({
    Key? key,
    required String name,
    String? Function(double?)? validator,
    required double initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(double?)? onChanged,
    dynamic Function(double?)? valueTransformer,
    bool enabled = true,
    void Function(double?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    required double min,
    required double max,
    int? divisions,
    Color? activeColor,
    Color? inactiveColor,
    void Function(double)? onChangeStart,
    void Function(double)? onChangeEnd,
    String? label,
    String Function(double)? semanticFormatterCallback,
    NumberFormat? numberFormat,
    DisplayValues displayValues = DisplayValues.all,
    bool autofocus = false,
    MouseCursor? mouseCursor,
    Widget Function(String)? maxValueWidget,
    Widget Function(String)? minValueWidget,
    Widget Function(String)? valueWidget,
  }) : super(
          key: key,
          name: name,
          validator: validator,
          initialValue: initialValue,
          decoration: decoration,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          enabled: enabled,
          onSaved: onSaved,
          autovalidateMode: autovalidateMode,
          onReset: onReset,
          focusNode: focusNode,
          restorationId: restorationId,
          min: min,
          max: max,
          divisions: divisions,
          activeColor: activeColor,
          inactiveColor: inactiveColor,
          onChangeStart: onChangeStart,
          onChangeEnd: onChangeEnd,
          label: label,
          semanticFormatterCallback: semanticFormatterCallback,
          numberFormat: numberFormat,
          displayValues: displayValues,
          autofocus: autofocus,
          mouseCursor: mouseCursor,
          maxValueWidget: maxValueWidget,
          minValueWidget: minValueWidget,
          valueWidget: valueWidget,
        );
}

class ProSwitch extends FormBuilderSwitch {
  // ignore: use_super_parameters
  ProSwitch({
    Key? key,
    required String name,
    String? Function(bool?)? validator,
    bool? initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(bool?)? onChanged,
    dynamic Function(bool?)? valueTransformer,
    bool enabled = true,
    void Function(bool?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    required Widget title,
    Color? activeColor,
    Color? activeTrackColor,
    Color? inactiveThumbColor,
    Color? inactiveTrackColor,
    ImageProvider<Object>? activeThumbImage,
    ImageProvider<Object>? inactiveThumbImage,
    Widget? subtitle,
    Widget? secondary,
    ListTileControlAffinity controlAffinity = ListTileControlAffinity.trailing,
    EdgeInsets contentPadding = EdgeInsets.zero,
    bool autofocus = false,
    bool selected = false,
  }) : super(
          key: key,
          name: name,
          validator: validator,
          initialValue: initialValue,
          decoration: decoration,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          enabled: enabled,
          onSaved: onSaved,
          autovalidateMode: autovalidateMode,
          onReset: onReset,
          focusNode: focusNode,
          restorationId: restorationId,
          title: title,
          activeColor: activeColor,
          activeTrackColor: activeTrackColor,
          inactiveTrackColor: inactiveTrackColor,
          activeThumbImage: activeThumbImage,
          inactiveThumbImage: inactiveThumbImage,
          subtitle: subtitle,
          secondary: secondary,
          controlAffinity: controlAffinity,
          contentPadding: contentPadding,
          autofocus: autofocus,
          selected: selected,
        );
}

class BaseWidgets {
  //Method to create a image.asset
  static Image proImageAsset({
    required String name,
    Key? key,
    AssetBundle? bundle,
    Widget Function(BuildContext, Widget, int?, bool)? frameBuilder,
    Widget Function(BuildContext, Object, StackTrace?)? errorBuilder,
    String? semanticLabel,
    bool excludeFromSemantics = false,
    double? scale,
    double? width,
    double? height,
    Color? color,
    Animation<double>? opacity,
    BlendMode? colorBlendMode,
    BoxFit? fit,
    AlignmentGeometry alignment = Alignment.center,
    ImageRepeat repeat = ImageRepeat.noRepeat,
    Rect? centerSlice,
    bool matchTextDirection = false,
    bool gaplessPlayback = false,
    bool isAntiAlias = false,
    String? package,
    FilterQuality filterQuality = FilterQuality.low,
    int? cacheWidth,
    int? cacheHeight,
  }) {
    return Image.asset(
      name,
      key: key,
      bundle: bundle,
      frameBuilder: frameBuilder,
      errorBuilder: errorBuilder,
      semanticLabel: semanticLabel,
      excludeFromSemantics: excludeFromSemantics,
      scale: scale,
      width: width,
      height: height,
      color: color,
      opacity: opacity,
      colorBlendMode: colorBlendMode,
      fit: fit,
      alignment: alignment,
      repeat: repeat,
      centerSlice: centerSlice,
      matchTextDirection: matchTextDirection,
      gaplessPlayback: gaplessPlayback,
      isAntiAlias: isAntiAlias,
      package: package,
      filterQuality: filterQuality,
      cacheWidth: cacheWidth,
      cacheHeight: cacheHeight,
    );
  }

  //Method to create a image.file
  static Image proImageFile(
      {required file,
      Key? key,
      double scale = 1.0,
      ImageFrameBuilder? frameBuilder,
      ImageErrorWidgetBuilder? errorBuilder,
      String? semanticLabel,
      bool excludeFromSemantics = false,
      double? width,
      double? height,
      Color? color,
      Animation<double>? opacity,
      BlendMode? colorBlendMode,
      BoxFit? fit,
      AlignmentGeometry alignment = Alignment.center,
      ImageRepeat repeat = ImageRepeat.noRepeat,
      Rect? centerSlice,
      bool matchTextDirection = false,
      bool gaplessPlayback = false,
      bool isAntiAlias = false,
      FilterQuality filterQuality = FilterQuality.low,
      int? cacheWidth,
      int? cacheHeight}) {
    return Image.file(
      file,
      key: key,
      scale: scale,
      frameBuilder: frameBuilder,
      errorBuilder: errorBuilder,
      semanticLabel: semanticLabel,
      excludeFromSemantics: excludeFromSemantics,
      width: width,
      height: height,
      color: color,
      opacity: opacity,
      colorBlendMode: colorBlendMode,
      fit: fit,
      alignment: alignment,
      repeat: repeat,
      centerSlice: centerSlice,
      matchTextDirection: matchTextDirection,
      gaplessPlayback: gaplessPlayback,
      isAntiAlias: isAntiAlias,
      filterQuality: filterQuality,
      cacheWidth: cacheWidth,
      cacheHeight: cacheHeight,
    );
  }

  //Method to create an image.memory
  static Image proImageMemory(
      {required bytes,
      Key? key,
      double scale = 1.0,
      ImageFrameBuilder? frameBuilder,
      ImageErrorWidgetBuilder? errorBuilder,
      String? semanticLabel,
      bool excludeFromSemantics = false,
      double? width,
      double? height,
      Color? color,
      Animation<double>? opacity,
      BlendMode? colorBlendMode,
      BoxFit? fit,
      AlignmentGeometry alignment = Alignment.center,
      ImageRepeat repeat = ImageRepeat.noRepeat,
      Rect? centerSlice,
      bool matchTextDirection = false,
      bool gaplessPlayback = false,
      bool isAntiAlias = false,
      FilterQuality filterQuality = FilterQuality.low,
      int? cacheWidth,
      int? cacheHeight}) {
    return Image.memory(
      bytes,
      scale: scale,
      frameBuilder: frameBuilder,
      errorBuilder: errorBuilder,
      semanticLabel: semanticLabel,
      excludeFromSemantics: excludeFromSemantics,
      width: width,
      height: height,
      color: color,
      opacity: opacity,
      colorBlendMode: colorBlendMode,
      fit: fit,
      alignment: alignment,
      repeat: repeat,
      centerSlice: centerSlice,
      matchTextDirection: matchTextDirection,
      gaplessPlayback: gaplessPlayback,
      isAntiAlias: isAntiAlias,
      filterQuality: filterQuality,
      cacheWidth: cacheWidth,
      cacheHeight: cacheHeight,
    );
  }

  //Method to create an image.network
  static Image proImageNetwork(
      {required String src,
      Key? key,
      double scale = 1.0,
      Widget Function(BuildContext, Widget, int?, bool)? frameBuilder,
      Widget Function(BuildContext, Widget, ImageChunkEvent?)? loadingBuilder,
      Widget Function(BuildContext, Object, StackTrace?)? errorBuilder,
      String? semanticLabel,
      bool excludeFromSemantics = false,
      double? width,
      double? height,
      Color? color,
      Animation<double>? opacity,
      BlendMode? colorBlendMode,
      BoxFit? fit,
      AlignmentGeometry alignment = Alignment.center,
      ImageRepeat repeat = ImageRepeat.noRepeat,
      Rect? centerSlice,
      bool matchTextDirection = false,
      bool gaplessPlayback = false,
      FilterQuality filterQuality = FilterQuality.low,
      bool isAntiAlias = false,
      Map<String, String>? headers,
      int? cacheWidth,
      int? cacheHeight}) {
    return Image.network(
      src,
      scale: scale,
      frameBuilder: frameBuilder,
      loadingBuilder: loadingBuilder,
      errorBuilder: errorBuilder,
      semanticLabel: semanticLabel,
      excludeFromSemantics: excludeFromSemantics,
      width: width,
      height: height,
      color: color,
      opacity: opacity,
      colorBlendMode: colorBlendMode,
      fit: fit,
      alignment: alignment,
      repeat: repeat,
      centerSlice: centerSlice,
      matchTextDirection: matchTextDirection,
      gaplessPlayback: gaplessPlayback,
      filterQuality: filterQuality,
      isAntiAlias: isAntiAlias,
      headers: headers,
      cacheWidth: cacheWidth,
      cacheHeight: cacheHeight,
    );
  }
}



/*
// OLD///////////////////////////////////////////////////////////

// add button...
//Method to create a elevatedbutton
/*
  ElevatedButton proElevatedButton({
    required void Function()? onPressed,
    void Function()? onLongPress,
    void Function(bool)? onHover,
    void Function(bool)? onFocusChange,
    ButtonStyle? style,
    FocusNode? focusNode,
    bool autofocus = false,
    Clip clipBehavior = Clip.none,
    required Widget child,
  }) {
    return ElevatedButton(
      onPressed: onPressed,
      onLongPress: onLongPress,
      onHover: onHover,
      onFocusChange: onFocusChange,
      style: style,
      focusNode: focusNode,
      autofocus: autofocus,
      clipBehavior: clipBehavior,
      child: child,
    );
  }

  //Method to create a textbutton
  static TextButton proTextButton({
    required void Function()? onPressed,
    void Function()? onLongPress,
    void Function(bool)? onHover,
    void Function(bool)? onFocusChange,
    ButtonStyle? style,
    FocusNode? focusNode,
    bool autofocus = false,
    Clip clipBehavior = Clip.none,
    required Widget child,
    required TextAlign textAlign,
    required TextDirection textDirection,
  }) {
    return TextButton(
      onPressed: onPressed,
      onLongPress: onLongPress,
      onHover: onHover,
      onFocusChange: onFocusChange,
      style: style,
      focusNode: focusNode,
      autofocus: autofocus,
      clipBehavior: clipBehavior,
      child: child,
    );
  }

  //add image...
  static Image proImage({
    Key? key,
    required ImageProvider<Object> image,
    Widget Function(BuildContext, Widget, int?, bool)? frameBuilder,
    Widget Function(BuildContext, Widget, ImageChunkEvent?)? loadingBuilder,
    Widget Function(BuildContext, Object, StackTrace?)? errorBuilder,
    String? semanticLabel,
    bool excludeFromSemantics = false,
    double? width,
    double? height,
    Color? color,
    Animation<double>? opacity,
    BlendMode? colorBlendMode,
    BoxFit? fit,
    AlignmentGeometry alignment = Alignment.center,
    ImageRepeat repeat = ImageRepeat.noRepeat,
    Rect? centerSlice,
    bool matchTextDirection = false,
    bool gaplessPlayback = false,
    bool isAntiAlias = false,
    FilterQuality filterQuality = FilterQuality.low,
  }) {
    return Image(
      key: key,
      image: image,
      frameBuilder: frameBuilder,
      loadingBuilder: loadingBuilder,
      errorBuilder: errorBuilder,
      semanticLabel: semanticLabel,
      excludeFromSemantics: excludeFromSemantics,
      width: width,
      height: height,
      color: color,
      opacity: opacity,
      colorBlendMode: colorBlendMode,
      fit: fit,
      alignment: alignment,
      repeat: repeat,
      centerSlice: centerSlice,
      matchTextDirection: matchTextDirection,
      gaplessPlayback: gaplessPlayback,
      isAntiAlias: isAntiAlias,
      filterQuality: filterQuality,
    );
  }

  //add text...
  //Method to create an text
  static Text proText({
    required dynamic data,
    Key? key,
    TextStyle? style,
    StrutStyle? strutStyle,
    TextAlign? textAlign,
    TextDirection? textDirection,
    Locale? locale,
    bool? softWrap,
    TextOverflow? overflow,
    TextScaler? textScaler,
    int? maxLines,
    String? semanticsLabel,
    TextWidthBasis? textWidthBasis,
    TextHeightBehavior? textHeightBehavior,
    Color? selectionColor,
  }) {
    return Text(
      data,
      style: style,
      textAlign: textAlign,
      textDirection: textDirection,
      locale: locale,
      softWrap: softWrap,
      overflow: overflow,
      textScaler: textScaler,
      maxLines: maxLines,
      semanticsLabel: semanticsLabel,
      textWidthBasis: textWidthBasis,
      textHeightBehavior: textHeightBehavior,
      selectionColor: selectionColor,
    );
  }

//add column....
  //Method to create a column
  static Column proColumn({
    Key? key,
    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,
    MainAxisSize mainAxisSize = MainAxisSize.max,
    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,
    TextDirection? textDirection,
    VerticalDirection verticalDirection = VerticalDirection.down,
    TextBaseline? textBaseline,
    List<Widget> children = const [],
  }) {
    return Column(
      key: key,
      mainAxisAlignment: mainAxisAlignment,
      mainAxisSize: mainAxisSize,
      crossAxisAlignment: crossAxisAlignment,
      textDirection: textDirection,
      verticalDirection: verticalDirection,
      textBaseline: textBaseline,
      children: children,
    );
  }

  //add container...
  //Method to create a container
  static Container proContainer({
    Key? key,
    AlignmentGeometry? alignment,
    EdgeInsetsGeometry? padding,
    Color? color,
    Decoration? decoration,
    Decoration? foregroundDecoration,
    double? width,
    double? height,
    BoxConstraints? constraints,
    EdgeInsetsGeometry? margin,
    Matrix4? transform,
    AlignmentGeometry? transformAlignment,
    Widget? child,
    Clip clipBehavior = Clip.none,
  }) {
    return Container(
      alignment: alignment,
      padding: padding,
      color: color,
      decoration: decoration,
      foregroundDecoration: foregroundDecoration,
      width: width,
      height: height,
      constraints: constraints,
      margin: margin,
      transform: transform,
      transformAlignment: transformAlignment,
      clipBehavior: clipBehavior,
      child: child,
    );
  }

    //Method to create an row
  static Row proRow(
      {Key? key,
      MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,
      MainAxisSize mainAxisSize = MainAxisSize.max,
      CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,
      TextDirection? textDirection,
      VerticalDirection verticalDirection = VerticalDirection.down,
      TextBaseline? textBaseline,
      List<Widget> children = const <Widget>[]}) {
    return Row(
      key: key,
      mainAxisAlignment: mainAxisAlignment,
      mainAxisSize: mainAxisSize,
      crossAxisAlignment: crossAxisAlignment,
      textDirection: textDirection,
      verticalDirection: verticalDirection,
      textBaseline: textBaseline,
      children: children,
    );
  }
  static FormBuilderCheckbox proCheckbox(
      {Key? key,
      required String name,
      String? Function(bool?)? validator,
      bool? initialValue,
      InputDecoration decoration = const InputDecoration(
          border: InputBorder.none,
          focusedBorder: InputBorder.none,
          enabledBorder: InputBorder.none,
          errorBorder: InputBorder.none,
          disabledBorder: InputBorder.none),
      void Function(bool?)? onChanged,
      dynamic Function(bool?)? valueTransformer,
      bool enabled = true,
      void Function(bool?)? onSaved,
      AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
      void Function()? onReset,
      FocusNode? focusNode,
      String? restorationId,
      required Widget title,
      Color? activeColor,
      bool autofocus = false,
      Color? checkColor,
      EdgeInsets contentPadding = EdgeInsets.zero,
      VisualDensity? visualDensity,
      ListTileControlAffinity controlAffinity = ListTileControlAffinity.leading,
      Widget? secondary,
      bool selected = false,
      Widget? subtitle,
      bool tristate = false,
      OutlinedBorder? shape,
      BorderSide? side}) {
    return FormBuilderCheckbox(
        key: key,
        name: name,
        validator: validator,
        initialValue: initialValue,
        decoration: decoration,
        onChanged: onChanged,
        valueTransformer: valueTransformer,
        enabled: enabled,
        onSaved: onSaved,
        autovalidateMode: autovalidateMode,
        onReset: onReset,
        focusNode: focusNode,
        restorationId: restorationId,
        title: title,
        activeColor: activeColor,
        autofocus: autofocus,
        checkColor: checkColor,
        contentPadding: contentPadding,
        visualDensity: visualDensity,
        controlAffinity: controlAffinity,
        secondary: secondary,
        selected: selected,
        subtitle: subtitle,
        tristate: tristate,
        shape: shape,
        side: side);
  }


*/

  // Method to create a text.rich
  static Text proTextRich(
      {required InlineSpan textSpan,
      Key? key,
      TextStyle? style,
      StrutStyle? strutStyle,
      TextAlign? textAlign,
      TextDirection? textDirection,
      Locale? locale,
      bool? softWrap,
      TextOverflow? overflow,
      TextScaler? textScaler,
      int? maxLines,
      String? semanticsLabel,
      TextWidthBasis? textWidthBasis,
      TextHeightBehavior? textHeightBehavior,
      Color? selectionColor}) {
    return Text.rich(
      textSpan,
      style: style,
      strutStyle: strutStyle,
      textAlign: textAlign,
      textDirection: textDirection,
      locale: locale,
      softWrap: softWrap,
      overflow: overflow,
      textScaler: textScaler,
      maxLines: maxLines,
      semanticsLabel: semanticsLabel,
      textWidthBasis: textWidthBasis,
      textHeightBehavior: textHeightBehavior,
      selectionColor: selectionColor,
    );
  }

  //add gridview...
  //Method to create a gridview
  /*    static GridView proGridView({
            Key? key,
            Axis scrollDirection = Axis.vertical,
            bool reverse = false,
            ScrollController? controller,
            bool? primary,
            ScrollPhysics? physics,
            bool shrinkWrap = false,
            EdgeInsetsGeometry? padding,
            required SliverGridDelegate gridDelegate,
            bool addAutomaticKeepAlives = true,
            bool addRepaintBoundaries = true,
            bool addSemanticIndexes = true,
            double? cacheExtent,
            List<Widget> children = const <Widget>[],
            int? semanticChildCount,
            Clip clipBehavior = Clip.hardEdge,
            ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual,
            dynamic String,
           }){
               return GridView(
                 gridDelegate: gridDelegate,
                 scrollDirection: scrollDirection,
                 reverse: reverse,
                 controller: controller,
                 primary: primary, 
                 physics: physics,
                 shrinkWrap: shrinkWrap,
                 padding: padding,
                 addAutomaticKeepAlives: addAutomaticKeepAlives,
                 addRepaintBoundaries: addRepaintBoundaries,
                 addSemanticIndexes: addSemanticIndexes,
                 cacheExtent: cacheExtent,
                 semanticChildCount: semanticChildCount,
                 clipBehavior: clipBehavior,
                 keyboardDismissBehavior: keyboardDismissBehavior,
                 children: children,
                );
              }


  //add table material....
  //Method to create an tablematerial
     static Table proTableMaterial({
            required List<List<String>> data,
            required int columnCount,
            Map<int, TableColumnWidth>? columnWidths,
            TableBorder? border,
            TableCellVerticalAlignment defaultVerticalAlignment = TableCellVerticalAlignment.middle,
            TextStyle? headerStyle,
            TextStyle? cellStyle,
            EdgeInsetsGeometry? cellPadding,
            AlignmentGeometry? cellAlignment,
            }){
                return Table(
                     border: border ?? TableBorder.all(),
                   columnWidths: columnWidths,
                   defaultVerticalAlignment: defaultVerticalAlignment,
                   children: List<TableRow>.generate(
                     data.length,
                     (rowIndex) {
                       return TableRow(
                         children: List<Widget>.generate(
                           columnCount,
                           (colIndex) {
                             bool isHeader = rowIndex == 0;
                             return Padding(
                               padding: cellPadding ?? const EdgeInsets.all(8.0),
                               child: Align(
                                 alignment: cellAlignment ?? Alignment.center,
                                 child: Text(
                                   data[rowIndex][colIndex],
                                   style: isHeader ? headerStyle : cellStyle,
                                 ),
                               ),
                             );
                           },
                        ),
                      );
                    },
                  ),
                );
              }  */

  //Method to create a linearprogressindicator
  static LinearProgressIndicator prolinearProgressIndicator({
    Key? key,
    double? value,
    Color? backgroundColor,
    Color? color,
    Animation<Color?>? valueColor,
    double? minHeight,
    String? semanticsLabel,
    String? semanticsValue,
    BorderRadiusGeometry borderRadius = BorderRadius.zero,
  }) {
    return LinearProgressIndicator(
      value: value,
      backgroundColor: backgroundColor,
      color: color,
      valueColor: valueColor,
      minHeight: minHeight,
      semanticsLabel: semanticsLabel,
      semanticsValue: semanticsValue,
      borderRadius: borderRadius,
    );
  }

  //Method to create a bottomsheet
  /*    static BottomSheet proBottomSheet({
           Key? key,
           AnimationController? animationController,
           bool enableDrag = true,
           bool? showDragHandle,
           Color? dragHandleColor,
           Size? dragHandleSize,
           void Function(DragStartDetails)? onDragStart,
           void Function(DragEndDetails, {required bool isClosing})? onDragEnd,
           Color? backgroundColor,
           Color? shadowColor,
           double? elevation,
           ShapeBorder? shape,
           Clip? clipBehavior,
           BoxConstraints? constraints,
           required VoidCallback onClosing,
           required WidgetBuilder builder
         }){
              return BottomSheet(
                key: key,
                animationController: animationController,
                enableDrag: enableDrag,
                showDragHandle: showDragHandle,
                dragHandleColor: dragHandleColor,
                dragHandleSize: dragHandleSize,
                onDragStart: onDragStart,
                onDragEnd: onDragEnd,
                backgroundColor: backgroundColor,
                shadowColor: shadowColor,
                elevation: elevation,
                shape: shape,
                clipBehavior: clipBehavior,
                constraints: constraints,
                onClosing: onClosing,
                builder: builder,
              );
           }


  //Method to create a alertdialog
       static AlertDialog proAlertDialog({
           Key? key,
           Widget? icon,
           EdgeInsetsGeometry? iconPadding,
           Color? iconColor,
           Widget? title,
           EdgeInsetsGeometry? titlePadding,
           TextStyle? titleTextStyle,
           Widget? content,
           EdgeInsetsGeometry? contentPadding,
           TextStyle? contentTextStyle,
           List<Widget>? actions,
           EdgeInsetsGeometry? actionsPadding,
           MainAxisAlignment? actionsAlignment,
           OverflowBarAlignment? actionsOverflowAlignment,
           VerticalDirection? actionsOverflowDirection,
           double? actionsOverflowButtonSpacing,
           EdgeInsetsGeometry? buttonPadding,
           Color? backgroundColor,
           double? elevation,
           Color? shadowColor,
           Color? surfaceTintColor,
           String? semanticLabel,
           EdgeInsets? insetPadding,
           Clip clipBehavior = Clip.none,
           ShapeBorder? shape,
           AlignmentGeometry? alignment,
           bool scrollable = false
          }){
              return AlertDialog(
                key:key,
                icon: icon,
                iconPadding: iconPadding,
                iconColor: iconColor,
                title: title,
                titlePadding: titlePadding,
                titleTextStyle: titleTextStyle,
                content: content,
                contentPadding: contentPadding,
                contentTextStyle: contentTextStyle,
                actions: actions,
                actionsPadding: actionsPadding,
                actionsAlignment: actionsAlignment,
                actionsOverflowAlignment: actionsOverflowAlignment,
                actionsOverflowButtonSpacing: actionsOverflowButtonSpacing,
                buttonPadding: buttonPadding,
                backgroundColor: backgroundColor,
                elevation: elevation,
                shadowColor:  shadowColor,
                surfaceTintColor: surfaceTintColor,
                semanticLabel: semanticLabel,
                insetPadding: insetPadding,
                clipBehavior: clipBehavior,
                shape: shape,
                alignment: alignment,
                scrollable: scrollable,
              );
            }


  //Method to create a divider
       static Divider proDivider({
           Key? key,
           double? height,
           double? thickness,
           double? indent,
           double? endIndent,
           Color? color,
          }){
               return Divider(
                 key: key,
                 height: height,
                 thickness: thickness,
                 indent: indent,
                 endIndent: endIndent,
                 color: color,
               );
            } 


  //Method to create an list
      static ListView proListView({
          Key? key,
          Axis scrollDirection = Axis.vertical,
          bool reverse = false,
          ScrollController? controller,
          bool? primary,
          ScrollPhysics? physics,
          bool shrinkWrap = false,
          EdgeInsetsGeometry? padding,
          double? itemExtent,
          required itemExtentBuilder,
          Widget? prototypeItem,
          bool addAutomaticKeepAlives = true,
          bool addRepaintBoundaries = true,
          bool addSemanticIndexes = true,
          double? cacheExtent,
          List<Widget> children = const <Widget>[],
          int? semanticChildCount,
          dynamic dragStartBehavior,
          ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual,
          String? restorationId,
          Clip clipBehavior = Clip.hardEdge, required ListTile Function(dynamic context, dynamic index) itemBuilder, required int itemCount,
          }){ 
               return ListView(
                key:key,
                scrollDirection: scrollDirection,
                reverse: reverse,
                controller: controller,
                primary: primary,
                shrinkWrap: shrinkWrap,
                physics: physics,
                padding: padding,
                itemExtent: itemExtent,
                itemExtentBuilder: itemExtentBuilder,
                prototypeItem: prototypeItem,
                addAutomaticKeepAlives: addAutomaticKeepAlives,
                addRepaintBoundaries: addRepaintBoundaries,
                addSemanticIndexes: addSemanticIndexes,
                cacheExtent: cacheExtent,
                semanticChildCount: semanticChildCount,
                dragStartBehavior: dragStartBehavior,
                keyboardDismissBehavior: keyboardDismissBehavior,
                restorationId: restorationId,
                clipBehavior: clipBehavior,
                children: children,
                );
             }


  //Method to create an listtile
      static ListTile proListTile({
           Key? key,
           Widget? leading,
           Widget? title,
           Widget? subtitle,
           Widget? trailing,
           bool isThreeLine = false,
           bool? dense,
           VisualDensity? visualDensity,
           ShapeBorder? shape,
           ListTileStyle? style,
           Color? selectedColor,
           Color? iconColor,
           Color? textColor,
           TextStyle? titleTextStyle,
           TextStyle? subtitleTextStyle,
           TextStyle? leadingAndTrailingTextStyle,
           EdgeInsetsGeometry? contentPadding,
           bool enabled = true,
           GestureTapCallback? onTap,
           GestureLongPressCallback? onLongPress,
           ValueChanged<bool>? onFocusChange,
           MouseCursor? mouseCursor,
           bool selected = false,
           Color? focusColor,
           Color? hoverColor,
           Color? splashColor,
           FocusNode? focusNode,
           bool autofocus = false,
           Color? tileColor,
           Color? selectedTileColor,
           bool? enableFeedback,
           double? horizontalTitleGap,
           double? minVerticalPadding,
           double? minLeadingWidth,
           double? minTileHeight,
           ListTileTitleAlignment? titleAlignment
          }){ 
               return ListTile(
                key: key,
                leading: leading,
                title: title,
                subtitle: subtitle,
                trailing: trailing,
                isThreeLine: isThreeLine,
                dense: dense,
                visualDensity: visualDensity,
                shape: shape,
                style: style,
                selectedColor: selectedColor,
                iconColor: iconColor,
                textColor: textColor,
                titleTextStyle: titleTextStyle,
                subtitleTextStyle: subtitleTextStyle,
                leadingAndTrailingTextStyle: leadingAndTrailingTextStyle,
                contentPadding: contentPadding,
                enabled: enabled,
                onTap: onTap,
                onLongPress: onLongPress,
                onFocusChange: onFocusChange,
                mouseCursor: mouseCursor,
                selected: selected,
                focusColor: focusColor,
                hoverColor: hoverColor,
                splashColor: splashColor,
                focusNode: focusNode,
                autofocus: autofocus,
                tileColor: tileColor,
                selectedTileColor: selectedTileColor,
                enableFeedback: enableFeedback,
                horizontalTitleGap: horizontalTitleGap,
                minVerticalPadding: minVerticalPadding,
                minLeadingWidth: minLeadingWidth,
                minTileHeight: minTileHeight,
                titleAlignment: titleAlignment,
               );
            }*/

  static Widget _defaultContextMenuBuilder(
    BuildContext context,
    EditableTextState editableTextState,
  ) {
    return AdaptiveTextSelectionToolbar.editableText(
      editableTextState: editableTextState,
    );
  }

//----------------------Form Builder Controls-----------------//

  static FormBuilderChoiceChip<dynamic> proChoiceChip({
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    bool enabled = true,
    FocusNode? focusNode,
    void Function(dynamic)? onSaved,
    String? Function(dynamic)? validator,
    InputDecoration decoration = const InputDecoration(),
    Key? key,
    required String name,
    required List<FormBuilderChipOption<dynamic>> options,
    dynamic initialValue,
    String? restorationId,
    void Function(dynamic)? onChanged,
    dynamic Function(dynamic)? valueTransformer,
    void Function()? onReset,
    WrapAlignment alignment = WrapAlignment.start,
    ShapeBorder avatarBorder = const CircleBorder(),
    Color? backgroundColor,
    WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start,
    Axis direction = Axis.horizontal,
    Color? disabledColor,
    double? elevation,
    EdgeInsets? labelPadding,
    TextStyle? labelStyle,
    MaterialTapTargetSize? materialTapTargetSize,
    EdgeInsets? padding,
    double? pressElevation,
    WrapAlignment runAlignment = WrapAlignment.start,
    double runSpacing = 0.0,
    Color? selectedColor,
    Color? selectedShadowColor,
    Color? shadowColor,
    OutlinedBorder? shape,
    double spacing = 0.0,
    TextDirection? textDirection,
    VerticalDirection verticalDirection = VerticalDirection.down,
    VisualDensity? visualDensity,
  }) {
    return FormBuilderChoiceChip(
      autovalidateMode: autovalidateMode,
      enabled: enabled,
      focusNode: focusNode,
      onSaved: onSaved,
      validator: validator,
      decoration: decoration,
      key: key,
      name: name,
      options: options,
      initialValue: initialValue,
      restorationId: restorationId,
      onChanged: onChanged,
      valueTransformer: valueTransformer,
      onReset: onReset,
      alignment: alignment,
      avatarBorder: avatarBorder,
      backgroundColor: backgroundColor,
      crossAxisAlignment: crossAxisAlignment,
      direction: direction,
      disabledColor: disabledColor,
      elevation: elevation,
      labelPadding: labelPadding,
      labelStyle: labelStyle,
      materialTapTargetSize: materialTapTargetSize,
      padding: padding,
      pressElevation: pressElevation,
      runAlignment: runAlignment,
      runSpacing: runSpacing,
      selectedColor: selectedColor,
      selectedShadowColor: selectedShadowColor,
      shadowColor: shadowColor,
      shape: shape,
      spacing: spacing,
      textDirection: textDirection,
      verticalDirection: verticalDirection,
      visualDensity: visualDensity,
    );
  }

  static FormBuilderDateRangePicker proDateRangePicker({
    Key? key,
    required String name,
    String? Function(DateTimeRange?)? validator,
    DateTimeRange? initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(DateTimeRange?)? onChanged,
    dynamic Function(DateTimeRange?)? valueTransformer,
    bool enabled = true,
    void Function(DateTimeRange?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    required DateTime firstDate,
    required DateTime lastDate,
    DateFormat? format,
    int maxLines = 1,
    bool obscureText = false,
    TextCapitalization textCapitalization = TextCapitalization.none,
    EdgeInsets scrollPadding = const EdgeInsets.all(20.0),
    bool enableInteractiveSelection = true,
    MaxLengthEnforcement? maxLengthEnforcement,
    TextAlign textAlign = TextAlign.start,
    TextAlignVertical? textAlignVertical,
    bool autofocus = false,
    bool autocorrect = true,
    double cursorWidth = 2.0,
    TextInputType? keyboardType,
    TextStyle? style,
    TextEditingController? controller,
    TextInputAction? textInputAction,
    StrutStyle? strutStyle,
    TextDirection? textDirection,
    int? maxLength,
    void Function()? onEditingComplete,
    void Function(DateTimeRange?)? onFieldSubmitted,
    List<TextInputFormatter>? inputFormatters,
    Radius? cursorRadius,
    Color? cursorColor,
    Brightness? keyboardAppearance,
    Widget? Function(BuildContext,
            {required int currentLength,
            required bool isFocused,
            required int? maxLength})?
        buildCounter,
    MouseCursor? mouseCursor,
    bool expands = false,
    int? minLines,
    bool showCursor = false,
    Locale? locale,
    String? cancelText,
    String? confirmText,
    DateTime? currentDate,
    String? errorFormatText,
    Widget Function(BuildContext, Widget?)? pickerBuilder,
    String? errorInvalidRangeText,
    String? errorInvalidText,
    String? fieldEndHintText,
    String? fieldEndLabelText,
    String? fieldStartHintText,
    String? fieldStartLabelText,
    String? helpText,
    DatePickerEntryMode initialEntryMode = DatePickerEntryMode.calendar,
    RouteSettings? routeSettings,
    String? saveText,
    bool useRootNavigator = true,
    bool allowClear = false,
    Widget? clearIcon,
  }) {
    return FormBuilderDateRangePicker(
      key: key,
      name: name,
      validator: validator,
      initialValue: initialValue,
      decoration: decoration,
      onChanged: onChanged,
      valueTransformer: valueTransformer,
      enabled: enabled,
      onSaved: onSaved,
      autovalidateMode: autovalidateMode,
      onReset: onReset,
      focusNode: focusNode,
      restorationId: restorationId,
      firstDate: firstDate,
      lastDate: lastDate,
      format: format,
      maxLines: maxLines,
      obscureText: obscureText,
      textCapitalization: textCapitalization,
      scrollPadding: scrollPadding,
      enableInteractiveSelection: enableInteractiveSelection,
      maxLengthEnforcement: maxLengthEnforcement,
      textAlign: textAlign,
      textAlignVertical: textAlignVertical,
      autofocus: autofocus,
      autocorrect: autocorrect,
      cursorWidth: cursorWidth,
      keyboardType: keyboardType,
      style: style,
      controller: controller,
      textInputAction: textInputAction,
      strutStyle: strutStyle,
      textDirection: textDirection,
      maxLength: maxLength,
      onEditingComplete: onEditingComplete,
      onFieldSubmitted: onFieldSubmitted,
      inputFormatters: inputFormatters,
      cursorRadius: cursorRadius,
      cursorColor: cursorColor,
      keyboardAppearance: keyboardAppearance,
      buildCounter: buildCounter,
      mouseCursor: mouseCursor,
      expands: expands,
      minLines: minLines,
      showCursor: showCursor,
      locale: locale,
      cancelText: cancelText,
      confirmText: confirmText,
      currentDate: currentDate,
      errorFormatText: errorFormatText,
      pickerBuilder: pickerBuilder,
      errorInvalidRangeText: errorInvalidRangeText,
      errorInvalidText: errorInvalidText,
      fieldEndHintText: fieldEndHintText,
      fieldEndLabelText: fieldEndLabelText,
      fieldStartHintText: fieldStartHintText,
      fieldStartLabelText: fieldStartLabelText,
      helpText: helpText,
      initialEntryMode: initialEntryMode,
      routeSettings: routeSettings,
      saveText: saveText,
      useRootNavigator: useRootNavigator,
      allowClear: allowClear,
      clearIcon: clearIcon,
    );
  }

  static FormBuilderDateTimePicker proDateTimePicker({
    Key? key,
    required String name,
    String? Function(DateTime?)? validator,
    DateTime? initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(DateTime?)? onChanged,
    dynamic Function(DateTime?)? valueTransformer,
    bool enabled = true,
    void Function(DateTime?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    InputType inputType = InputType.both,
    EdgeInsets scrollPadding = const EdgeInsets.all(20.0),
    double cursorWidth = 2.0,
    bool enableInteractiveSelection = true,
    Widget? resetIcon = const Icon(Icons.close),
    TimeOfDay initialTime = const TimeOfDay(hour: 12, minute: 0),
    TextInputType? keyboardType,
    TextAlign textAlign = TextAlign.start,
    bool autofocus = false,
    bool obscureText = false,
    bool autocorrect = true,
    int? maxLines = 1,
    bool expands = false,
    DatePickerMode initialDatePickerMode = DatePickerMode.day,
    Widget Function(BuildContext, Widget?)? transitionBuilder,
    TextCapitalization textCapitalization = TextCapitalization.none,
    bool useRootNavigator = true,
    DatePickerEntryMode initialEntryMode = DatePickerEntryMode.calendar,
    TimePickerEntryMode timePickerInitialEntryMode = TimePickerEntryMode.dial,
    DateFormat? format,
    DateTime? initialDate,
    DateTime? firstDate,
    DateTime? lastDate,
    DateTime? currentDate,
    Locale? locale,
    int? maxLength,
    TextDirection? textDirection,
    TextAlignVertical? textAlignVertical,
    void Function(DateTime?)? onFieldSubmitted,
    TextEditingController? controller,
    TextStyle? style,
    MaxLengthEnforcement maxLengthEnforcement = MaxLengthEnforcement.none,
    List<TextInputFormatter>? inputFormatters,
    bool showCursor = false,
    int? minLines,
    TextInputAction? textInputAction,
    void Function()? onEditingComplete,
    Widget? Function(BuildContext,
            {required int currentLength,
            required bool isFocused,
            required int? maxLength})?
        buildCounter,
    MouseCursor? mouseCursor,
    Radius? cursorRadius,
    Color? cursorColor,
    Brightness? keyboardAppearance,
    String? cancelText,
    String? confirmText,
    String? errorFormatText,
    String? errorInvalidText,
    String? fieldHintText,
    String? fieldLabelText,
    String? helpText,
    RouteSettings? routeSettings,
    StrutStyle? strutStyle,
    bool Function(DateTime)? selectableDayPredicate,
    Offset? anchorPoint,
    void Function(TimePickerEntryMode)? onEntryModeChanged,
  }) {
    return FormBuilderDateTimePicker(
      key: key,
      name: name,
      validator: validator,
      initialValue: initialValue,
      decoration: decoration,
      onChanged: onChanged,
      valueTransformer: valueTransformer,
      enabled: enabled,
      onSaved: onSaved,
      autovalidateMode: autovalidateMode,
      onReset: onReset,
      focusNode: focusNode,
      restorationId: restorationId,
      inputType: inputType,
      scrollPadding: scrollPadding,
      cursorWidth: cursorWidth,
      enableInteractiveSelection: enableInteractiveSelection,
      resetIcon: resetIcon,
      initialTime: initialTime,
      keyboardType: keyboardType,
      textAlign: textAlign,
      autofocus: autofocus,
      obscureText: obscureText,
      autocorrect: autocorrect,
      maxLines: maxLines,
      expands: expands,
      initialDatePickerMode: initialDatePickerMode,
      transitionBuilder: transitionBuilder,
      textCapitalization: textCapitalization,
      useRootNavigator: useRootNavigator,
      initialEntryMode: initialEntryMode,
      timePickerInitialEntryMode: timePickerInitialEntryMode,
      format: format,
      initialDate: initialDate,
      firstDate: firstDate,
      lastDate: lastDate,
      currentDate: currentDate,
      locale: locale,
      maxLength: maxLength,
      textDirection: textDirection,
      textAlignVertical: textAlignVertical,
      onFieldSubmitted: onFieldSubmitted,
      controller: controller,
      style: style,
      maxLengthEnforcement: maxLengthEnforcement,
      inputFormatters: inputFormatters,
      showCursor: showCursor,
      minLines: minLines,
      textInputAction: textInputAction,
      onEditingComplete: onEditingComplete,
      buildCounter: buildCounter,
      mouseCursor: mouseCursor,
      cursorRadius: cursorRadius,
      cursorColor: cursorColor,
      keyboardAppearance: keyboardAppearance,
      cancelText: cancelText,
      confirmText: confirmText,
      errorFormatText: errorFormatText,
      errorInvalidText: errorInvalidText,
      fieldHintText: fieldHintText,
      fieldLabelText: fieldLabelText,
      helpText: helpText,
      routeSettings: routeSettings,
      strutStyle: strutStyle,
      selectableDayPredicate: selectableDayPredicate,
      anchorPoint: anchorPoint,
      onEntryModeChanged: onEntryModeChanged,
    );
  }

  static FormBuilderDropdown<T> proDropdown<T>({
    Key? key,
    required String name,
    String? Function(T?)? validator,
    T? initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(T?)? onChanged,
    dynamic Function(T?)? valueTransformer,
    bool enabled = true,
    void Function(T?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    required List<DropdownMenuItem<T>> items,
    bool isExpanded = true,
    bool isDense = true,
    int elevation = 8,
    double iconSize = 24.0,
    TextStyle? style,
    Widget? disabledHint,
    Widget? icon,
    Color? iconDisabledColor,
    Color? iconEnabledColor,
    void Function()? onTap,
    bool autofocus = false,
    Color? dropdownColor,
    Color? focusColor,
    double? itemHeight,
    List<Widget> Function(BuildContext)? selectedItemBuilder,
    double? menuMaxHeight,
    bool? enableFeedback,
    BorderRadius? borderRadius,
    AlignmentGeometry alignment = AlignmentDirectional.centerStart,
  }) {
    return FormBuilderDropdown<T>(
      key: key,
      name: name,
      validator: validator,
      initialValue: initialValue,
      decoration: decoration,
      onChanged: onChanged,
      valueTransformer: valueTransformer,
      enabled: enabled,
      onSaved: onSaved,
      autovalidateMode: autovalidateMode,
      onReset: onReset,
      focusNode: focusNode,
      restorationId: restorationId,
      items: items,
      isExpanded: isExpanded,
      isDense: isDense,
      elevation: elevation,
      iconSize: iconSize,
      style: style,
      disabledHint: disabledHint,
      icon: icon,
      iconDisabledColor: iconDisabledColor,
      iconEnabledColor: iconDisabledColor,
      onTap: onTap,
      autofocus: autofocus,
      dropdownColor: dropdownColor,
      focusColor: focusColor,
      itemHeight: itemHeight,
      selectedItemBuilder: selectedItemBuilder,
      menuMaxHeight: menuMaxHeight,
      enableFeedback: enableFeedback,
      borderRadius: borderRadius,
      alignment: alignment,
    );
  }

  static FormBuilderFilterChip proFilterChip({
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    bool enabled = true,
    FocusNode? focusNode,
    void Function(List<dynamic>?)? onSaved,
    String? Function(List<dynamic>?)? validator,
    InputDecoration decoration = const InputDecoration(),
    Key? key,
    List<dynamic>? initialValue,
    required String name,
    String? restorationId,
    required List<FormBuilderChipOption<dynamic>> options,
    WrapAlignment alignment = WrapAlignment.start,
    ShapeBorder avatarBorder = const CircleBorder(),
    Color? backgroundColor,
    Color? checkmarkColor,
    Clip clipBehavior = Clip.none,
    WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start,
    Axis direction = Axis.horizontal,
    Color? disabledColor,
    double? elevation,
    EdgeInsets? labelPadding,
    TextStyle? labelStyle,
    MaterialTapTargetSize? materialTapTargetSize,
    int? maxChips,
    EdgeInsets? padding,
    double? pressElevation,
    WrapAlignment runAlignment = WrapAlignment.start,
    double runSpacing = 0.0,
    Color? selectedColor,
    Color? selectedShadowColor,
    Color? shadowColor,
    OutlinedBorder? shape,
    bool showCheckmark = true,
    double spacing = 0.0,
    TextDirection? textDirection,
    VerticalDirection verticalDirection = VerticalDirection.down,
    void Function(List<dynamic>?)? onChanged,
    dynamic Function(List<dynamic>?)? valueTransformer,
    void Function()? onReset,
  }) {
    return FormBuilderFilterChip(
      autovalidateMode: autovalidateMode,
      enabled: enabled,
      focusNode: focusNode,
      onSaved: onSaved,
      validator: validator,
      decoration: decoration,
      key: key,
      initialValue: initialValue,
      name: name,
      restorationId: restorationId,
      options: options,
      alignment: alignment,
      avatarBorder: avatarBorder,
      backgroundColor: backgroundColor,
      checkmarkColor: checkmarkColor,
      clipBehavior: clipBehavior,
      crossAxisAlignment: crossAxisAlignment,
      direction: direction,
      disabledColor: disabledColor,
      elevation: elevation,
      labelPadding: labelPadding,
      labelStyle: labelStyle,
      materialTapTargetSize: materialTapTargetSize,
      maxChips: maxChips,
      padding: padding,
      pressElevation: pressElevation,
      runAlignment: runAlignment,
      runSpacing: runSpacing,
      selectedColor: selectedColor,
      selectedShadowColor: selectedShadowColor,
      shadowColor: shadowColor,
      shape: shape,
      showCheckmark: showCheckmark,
      spacing: spacing,
      textDirection: textDirection,
      verticalDirection: verticalDirection,
      onChanged: onChanged,
      valueTransformer: valueTransformer,
      onReset: onReset,
    );
  }

  static FormBuilderRadioGroup<T> proRadioGroup<T>({
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    bool enabled = true,
    FocusNode? focusNode,
    void Function(T?)? onSaved,
    String? Function(T?)? validator,
    InputDecoration decoration = const InputDecoration(),
    Key? key,
    required String name,
    required List<FormBuilderFieldOption<T>> options,
    T? initialValue,
    Color? activeColor,
    ControlAffinity controlAffinity = ControlAffinity.leading,
    List<T>? disabled,
    Color? focusColor,
    Color? hoverColor,
    MaterialTapTargetSize? materialTapTargetSize,
    OptionsOrientation orientation = OptionsOrientation.wrap,
    Widget? separator,
    WrapAlignment wrapAlignment = WrapAlignment.start,
    WrapCrossAlignment wrapCrossAxisAlignment = WrapCrossAlignment.start,
    Axis wrapDirection = Axis.horizontal,
    WrapAlignment wrapRunAlignment = WrapAlignment.start,
    double wrapRunSpacing = 0.0,
    double wrapSpacing = 0.0,
    TextDirection? wrapTextDirection,
    VerticalDirection wrapVerticalDirection = VerticalDirection.down,
    void Function(T?)? onChanged,
    dynamic Function(T?)? valueTransformer,
    void Function()? onReset,
    String? restorationId,
    BoxDecoration? itemDecoration,
  }) {
    return FormBuilderRadioGroup<T>(
        autovalidateMode: autovalidateMode,
        enabled: enabled,
        focusNode: focusNode,
        onSaved: onSaved,
        validator: validator,
        decoration: decoration,
        key: key,
        name: name,
        options: options,
        initialValue: initialValue,
        activeColor: activeColor,
        controlAffinity: controlAffinity,
        disabled: disabled,
        focusColor: focusColor,
        hoverColor: hoverColor,
        materialTapTargetSize: materialTapTargetSize,
        orientation: orientation,
        separator: separator,
        wrapAlignment: wrapAlignment,
        wrapCrossAxisAlignment: wrapCrossAxisAlignment,
        wrapDirection: wrapDirection,
        wrapRunAlignment: wrapRunAlignment,
        wrapRunSpacing: wrapRunSpacing,
        wrapSpacing: wrapSpacing,
        wrapTextDirection: wrapTextDirection,
        wrapVerticalDirection: wrapVerticalDirection,
        onChanged: onChanged,
        valueTransformer: valueTransformer,
        onReset: onReset,
        restorationId: restorationId,
        itemDecoration: itemDecoration);
  }

  static FormBuilderRangeSlider proRangeSlider({
    Key? key,
    required String name,
    String? Function(RangeValues?)? validator,
    RangeValues? initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(RangeValues?)? onChanged,
    dynamic Function(RangeValues?)? valueTransformer,
    bool enabled = true,
    void Function(RangeValues?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    required double min,
    required double max,
    int? divisions,
    Color? activeColor,
    Color? inactiveColor,
    void Function(RangeValues)? onChangeStart,
    void Function(RangeValues)? onChangeEnd,
    RangeLabels? labels,
    String Function(double)? semanticFormatterCallback,
    DisplayValues displayValues = DisplayValues.all,
    Widget Function(String)? minValueWidget,
    Widget Function(String)? valueWidget,
    Widget Function(String)? maxValueWidget,
    NumberFormat? numberFormat,
  }) {
    return FormBuilderRangeSlider(
      key: key,
      name: name,
      validator: validator,
      initialValue: initialValue,
      decoration: decoration,
      onChanged: onChanged,
      valueTransformer: valueTransformer,
      enabled: enabled,
      onSaved: onSaved,
      autovalidateMode: autovalidateMode,
      onReset: onReset,
      focusNode: focusNode,
      min: min,
      max: max,
      divisions: divisions,
      activeColor: activeColor,
      inactiveColor: inactiveColor,
      onChangeStart: onChangeStart,
      onChangeEnd: onChangeEnd,
      labels: labels,
      semanticFormatterCallback: semanticFormatterCallback,
      displayValues: displayValues,
      minValueWidget: minValueWidget,
      valueWidget: valueWidget,
      maxValueWidget: maxValueWidget,
      numberFormat: numberFormat,
    );
  }

  static FormBuilderSlider proSlider({
    Key? key,
    required String name,
    String? Function(double?)? validator,
    required double initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(double?)? onChanged,
    dynamic Function(double?)? valueTransformer,
    bool enabled = true,
    void Function(double?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    required double min,
    required double max,
    int? divisions,
    Color? activeColor,
    Color? inactiveColor,
    void Function(double)? onChangeStart,
    void Function(double)? onChangeEnd,
    String? label,
    String Function(double)? semanticFormatterCallback,
    NumberFormat? numberFormat,
    DisplayValues displayValues = DisplayValues.all,
    bool autofocus = false,
    MouseCursor? mouseCursor,
    Widget Function(String)? maxValueWidget,
    Widget Function(String)? minValueWidget,
    Widget Function(String)? valueWidget,
  }) {
    return FormBuilderSlider(
      key: key,
      name: name,
      validator: validator,
      initialValue: initialValue,
      decoration: decoration,
      onChanged: onChanged,
      valueTransformer: valueTransformer,
      enabled: enabled,
      onSaved: onSaved,
      autovalidateMode: autovalidateMode,
      onReset: onReset,
      focusNode: focusNode,
      restorationId: restorationId,
      min: min,
      max: max,
      divisions: divisions,
      activeColor: activeColor,
      inactiveColor: inactiveColor,
      onChangeStart: onChangeStart,
      onChangeEnd: onChangeEnd,
      label: label,
      semanticFormatterCallback: semanticFormatterCallback,
      numberFormat: numberFormat,
      displayValues: displayValues,
      autofocus: autofocus,
      mouseCursor: mouseCursor,
      maxValueWidget: maxValueWidget,
      minValueWidget: minValueWidget,
      valueWidget: valueWidget,
    );
  }

  static FormBuilderSwitch proSwitch({
    Key? key,
    required String name,
    String? Function(bool?)? validator,
    bool? initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(bool?)? onChanged,
    dynamic Function(bool?)? valueTransformer,
    bool enabled = true,
    void Function(bool?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    required Widget title,
    Color? activeColor,
    Color? activeTrackColor,
    Color? inactiveThumbColor,
    Color? inactiveTrackColor,
    ImageProvider<Object>? activeThumbImage,
    ImageProvider<Object>? inactiveThumbImage,
    Widget? subtitle,
    Widget? secondary,
    ListTileControlAffinity controlAffinity = ListTileControlAffinity.trailing,
    EdgeInsets contentPadding = EdgeInsets.zero,
    bool autofocus = false,
    bool selected = false,
  }) {
    return FormBuilderSwitch(
      key: key,
      name: name,
      validator: validator,
      initialValue: initialValue,
      decoration: decoration,
      onChanged: onChanged,
      valueTransformer: valueTransformer,
      enabled: enabled,
      onSaved: onSaved,
      autovalidateMode: autovalidateMode,
      onReset: onReset,
      focusNode: focusNode,
      restorationId: restorationId,
      title: title,
      activeColor: activeColor,
      activeTrackColor: activeTrackColor,
      inactiveTrackColor: inactiveTrackColor,
      activeThumbImage: activeThumbImage,
      inactiveThumbImage: inactiveThumbImage,
      subtitle: subtitle,
      secondary: secondary,
      controlAffinity: controlAffinity,
      contentPadding: contentPadding,
      autofocus: autofocus,
      selected: selected,
    );
  }

  static FormBuilderTextField proTextField(
      {Key? key,
      required String name,
      String? Function(String?)? validator,
      InputDecoration decoration = const InputDecoration(),
      void Function(String?)? onChanged,
      dynamic Function(String?)? valueTransformer,
      bool enabled = true,
      void Function(String?)? onSaved,
      AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
      void Function()? onReset,
      FocusNode? focusNode,
      String? restorationId,
      String? initialValue,
      bool readOnly = false,
      int? maxLines = 1,
      bool obscureText = false,
      TextCapitalization textCapitalization = TextCapitalization.none,
      EdgeInsets scrollPadding = const EdgeInsets.all(20.0),
      bool enableInteractiveSelection = true,
      MaxLengthEnforcement? maxLengthEnforcement,
      TextAlign textAlign = TextAlign.start,
      bool autofocus = false,
      bool autocorrect = true,
      double cursorWidth = 2.0,
      double? cursorHeight,
      TextInputType? keyboardType,
      TextStyle? style,
      TextEditingController? controller,
      TextInputAction? textInputAction,
      StrutStyle? strutStyle,
      TextDirection? textDirection,
      int? maxLength,
      void Function()? onEditingComplete,
      void Function(String?)? onSubmitted,
      List<TextInputFormatter>? inputFormatters,
      Radius? cursorRadius,
      Color? cursorColor,
      Brightness? keyboardAppearance,
      Widget? Function(BuildContext,
              {required int currentLength,
              required bool isFocused,
              required int? maxLength})?
          buildCounter,
      bool expands = false,
      int? minLines,
      bool? showCursor,
      void Function()? onTap,
      void Function(PointerDownEvent)? onTapOutside,
      bool enableSuggestions = false,
      TextAlignVertical? textAlignVertical,
      DragStartBehavior dragStartBehavior = DragStartBehavior.start,
      ScrollController? scrollController,
      ScrollPhysics? scrollPhysics,
      BoxWidthStyle selectionWidthStyle = BoxWidthStyle.tight,
      SmartDashesType? smartDashesType,
      SmartQuotesType? smartQuotesType,
      BoxHeightStyle selectionHeightStyle = BoxHeightStyle.tight,
      Iterable<String>? autofillHints,
      String obscuringCharacter = 'â€¢',
      MouseCursor? mouseCursor,
      Widget Function(BuildContext, EditableTextState)? contextMenuBuilder =
          _defaultContextMenuBuilder,
      TextMagnifierConfiguration? magnifierConfiguration,
      ContentInsertionConfiguration? contentInsertionConfiguration,
      SpellCheckConfiguration? spellCheckConfiguration}) {
    return FormBuilderTextField(
        key: key,
        name: name,
        validator: validator,
        decoration: decoration,
        onChanged: onChanged,
        valueTransformer: valueTransformer,
        enabled: enabled,
        onSaved: onSaved,
        autovalidateMode: autovalidateMode,
        onReset: onReset,
        focusNode: focusNode,
        restorationId: restorationId,
        initialValue: initialValue,
        readOnly: readOnly,
        maxLines: maxLines,
        obscureText: obscureText,
        textCapitalization: textCapitalization,
        scrollPadding: scrollPadding,
        enableInteractiveSelection: enableInteractiveSelection,
        maxLengthEnforcement: maxLengthEnforcement,
        textAlign: textAlign,
        autofocus: autofocus,
        autocorrect: autocorrect,
        cursorWidth: cursorWidth,
        cursorHeight: cursorHeight,
        keyboardType: keyboardType,
        style: style,
        controller: controller,
        textInputAction: textInputAction,
        strutStyle: strutStyle,
        textDirection: textDirection,
        maxLength: maxLength,
        onEditingComplete: onEditingComplete,
        onSubmitted: onSubmitted,
        inputFormatters: inputFormatters,
        cursorRadius: cursorRadius,
        cursorColor: cursorColor,
        keyboardAppearance: keyboardAppearance,
        buildCounter: buildCounter,
        expands: expands,
        minLines: minLines,
        showCursor: showCursor,
        onTap: onTap,
        onTapOutside: onTapOutside,
        enableSuggestions: enableSuggestions,
        textAlignVertical: textAlignVertical,
        dragStartBehavior: dragStartBehavior,
        scrollController: scrollController,
        scrollPhysics: scrollPhysics,
        selectionWidthStyle: selectionWidthStyle,
        smartDashesType: smartDashesType,
        smartQuotesType: smartQuotesType,
        selectionHeightStyle: selectionHeightStyle,
        autofillHints: autofillHints,
        obscuringCharacter: obscuringCharacter,
        mouseCursor: mouseCursor,
        contextMenuBuilder: contextMenuBuilder,
        magnifierConfiguration: magnifierConfiguration,
        contentInsertionConfiguration: contentInsertionConfiguration,
        spellCheckConfiguration: spellCheckConfiguration);
  }


*/
