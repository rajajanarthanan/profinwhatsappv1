// ignore_for_file: use_super_parameters

import 'dart:ui';

import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_form_builder/flutter_form_builder.dart';
import 'package:intl/intl.dart' show DateFormat;
import 'package:intl/intl.dart' show NumberFormat;

class ProContainer extends Container {
  // ignore: use_super_parameters
  ProContainer({
    Key? key,
    AlignmentGeometry? alignment,
    EdgeInsetsGeometry? padding =
        const EdgeInsets.symmetric(vertical: 2.0, horizontal: 2.0),
    Decoration? decoration,
    Decoration? foregroundDecoration,
    double? width,
    double? height,
    BoxConstraints? constraints,
    EdgeInsetsGeometry? margin = const EdgeInsets.all(10.0),
    Matrix4? transform,
    AlignmentGeometry? transformAlignment,
    Widget? child,
    Clip clipBehavior = Clip.none, required Color color,
  }) : super(
          key: key,
          alignment: alignment,
          padding: padding,
          decoration: decoration ??
              BoxDecoration(
                color: Colors.blue,
                borderRadius: BorderRadius.circular(10.0),
                boxShadow: [
                  BoxShadow(
                    color: Colors.grey.withOpacity(0.75),
                    spreadRadius: 2,
                    blurRadius: 2,
                    offset: const Offset(0, 0),
                  ),
                ],
              ),
          foregroundDecoration: foregroundDecoration,
          width: width,
          height: height,
          constraints: constraints,
          margin: margin,
          transform: transform,
          transformAlignment: transformAlignment,
          clipBehavior: clipBehavior,
          child: child,
        );
}

class ProColumn extends Column {
  // ignore: use_super_parameters
  const ProColumn({
    Key? key,
    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,
    MainAxisSize mainAxisSize = MainAxisSize.max,
    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,
    TextDirection? textDirection,
    VerticalDirection verticalDirection = VerticalDirection.down,
    TextBaseline? textBaseline,
    List<Widget> children = const [],
  }) : super(
          key: key,
          mainAxisAlignment: mainAxisAlignment,
          mainAxisSize: mainAxisSize,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          textBaseline: textBaseline,
          children: children,
        );
}

class ProRow extends Row {
  // ignore: use_super_parameters
  const ProRow({
    Key? key,
    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,
    MainAxisSize mainAxisSize = MainAxisSize.max,
    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,
    TextDirection? textDirection,
    VerticalDirection verticalDirection = VerticalDirection.down,
    TextBaseline? textBaseline,
    List<Widget> children = const <Widget>[],
  }) : super(
          key: key,
          mainAxisAlignment: mainAxisAlignment,
          mainAxisSize: mainAxisSize,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          textBaseline: textBaseline,
          children: children,
        );
}

class ProElevatedButton extends ElevatedButton {
  const ProElevatedButton({
    Key? key,
    required VoidCallback? onPressed,
    required Widget? child,
    VoidCallback? onLongPress,
    ButtonStyle? style,
    FocusNode? focusNode,
    bool autofocus = false,
    Clip clipBehavior = Clip.none,
  }) : super(
          key: key,
          onPressed: onPressed,
          onLongPress: onLongPress,
          style: style,
          focusNode: focusNode,
          autofocus: autofocus,
          clipBehavior: clipBehavior,
          child: child,
        );
}

class ProTextButton extends TextButton {
  // ignore: use_super_parameters
  const ProTextButton({
    Key? key,
    required VoidCallback? onPressed,
    required Widget child,
    VoidCallback? onLongPress,
    ButtonStyle? style,
    FocusNode? focusNode,
    bool autofocus = false,
    Clip clipBehavior = Clip.none,
    TextAlign textAlign = TextAlign.left,
    TextDirection textDirection = TextDirection.ltr,
  }) : super(
          key: key,
          onPressed: onPressed,
          onLongPress: onLongPress,
          style: style,
          focusNode: focusNode,
          autofocus: autofocus,
          clipBehavior: clipBehavior,
          child: child,
        );
}

class ProImage extends Image {
  const ProImage({
    Key? key,
    required ImageProvider<Object> image,
    Widget Function(BuildContext, Widget, int?, bool)? frameBuilder,
    Widget Function(BuildContext, Widget, ImageChunkEvent?)? loadingBuilder,
    Widget Function(BuildContext, Object, StackTrace?)? errorBuilder,
    String? semanticLabel,
    bool excludeFromSemantics = false,
    double? width,
    double? height,
    Color? color,
    Animation<double>? opacity,
    BlendMode? colorBlendMode,
    BoxFit? fit,
    AlignmentGeometry alignment = Alignment.center,
    ImageRepeat repeat = ImageRepeat.noRepeat,
    Rect? centerSlice,
    bool matchTextDirection = false,
    bool gaplessPlayback = false,
    bool isAntiAlias = false,
    FilterQuality filterQuality = FilterQuality.low,
  }) : super(
          key: key,
          image: image,
          frameBuilder: frameBuilder,
          loadingBuilder: loadingBuilder,
          errorBuilder: errorBuilder,
          semanticLabel: semanticLabel,
          excludeFromSemantics: excludeFromSemantics,
          width: width,
          height: height,
          color: color,
          opacity: opacity,
          colorBlendMode: colorBlendMode,
          fit: fit,
          alignment: alignment,
          repeat: repeat,
          centerSlice: centerSlice,
          matchTextDirection: matchTextDirection,
          gaplessPlayback: gaplessPlayback,
          isAntiAlias: isAntiAlias,
          filterQuality: filterQuality,
        );
}


 class ProIcon extends Icon {
  // ignore: use super parameters
  const ProIcon (
    IconData? icon,{
    Key? key,
    double? size,
    double? fill,
    double? weight,
    double? grade,
    double? opticalSize,
    Color? color,
    List<Shadow>? shadows,
    String? semanticLabel,
    TextDirection? textDirection,
    bool? applyTextScaling,
   } ):super(
      icon,
      key: key,
      size: size,
      fill: fill,
      weight: weight,
      grade: grade,
      opticalSize: opticalSize,
      color: color,
      shadows: shadows,
      semanticLabel: semanticLabel,
      textDirection: textDirection,
      applyTextScaling: applyTextScaling,
    );
 }


 class ProIconButton extends IconButton{
    // ignore: use super parameters
   const  ProIconButton ({
     Key? key,
     double? iconSize,
     VisualDensity? visualDensity,
     EdgeInsetsGeometry? padding,
     AlignmentGeometry? alignment,
     double? splashRadius,
     Color? color,
     Color? focusColor,
     Color? hoverColor,
     Color? highlightColor,
     Color? splashColor,
     Color? disabledColor,
     required void Function()? onPressed,
     MouseCursor? mouseCursor,
     FocusNode? focusNode,
     bool autofocus = false,
     String? tooltip,
     bool? enableFeedback,
     BoxConstraints? constraints,
     ButtonStyle? style,
     bool? isSelected,
     Widget? selectedIcon,
     required Widget icon,
     
    }): super(
          key: key,
          iconSize: iconSize,
          visualDensity: visualDensity,
          padding: padding ?? const EdgeInsets.all(8.0),
          alignment: alignment,
          splashRadius: splashRadius,
          color: color,
          focusColor: focusColor,
          hoverColor: hoverColor,
          highlightColor: highlightColor,
          splashColor: splashColor,
          disabledColor: disabledColor,
          onPressed: onPressed,
          mouseCursor: mouseCursor,
          focusNode: focusNode,
          autofocus: autofocus,
          tooltip: tooltip,
          enableFeedback: enableFeedback ?? true,
          constraints: constraints,
          icon: icon,
        );
 } 

class ProText extends Text {
  // ignore: use_super_parameters
  const ProText(
    dynamic data,{
    Key? key,
    TextStyle? style,
    StrutStyle? strutStyle,
    TextAlign? textAlign,
    TextDirection? textDirection,
    Locale? locale,
    bool? softWrap,
    TextOverflow? overflow,
    int? maxLines,
    String? semanticsLabel,
    TextWidthBasis? textWidthBasis,
    TextHeightBehavior? textHeightBehavior,
    Color? selectionColor,
  }) : super(
          data,
          key: key,
          style: style,
          strutStyle: strutStyle,
          textAlign: textAlign,
          textDirection: textDirection,
          locale: locale,
          softWrap: softWrap,
          overflow: overflow,
          maxLines: maxLines,
          semanticsLabel: semanticsLabel,
          textWidthBasis: textWidthBasis,
          textHeightBehavior: textHeightBehavior,
          selectionColor: selectionColor,
        );
}

class ProTextField extends FormBuilderTextField {
  ProTextField({
    Key? key,
    required String name,
    String? Function(String?)? validator,
    InputDecoration decoration = const InputDecoration(),
    void Function(String?)? onChanged,
    dynamic Function(String?)? valueTransformer,
    bool enabled = true,
    void Function(String?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    String? initialValue,
    bool readOnly = false,
    int? maxLines = 1,
    bool obscureText = false,
    TextCapitalization textCapitalization = TextCapitalization.none,
    EdgeInsets scrollPadding = const EdgeInsets.all(20.0),
    bool enableInteractiveSelection = true,
    MaxLengthEnforcement? maxLengthEnforcement,
    TextAlign textAlign = TextAlign.start,
    bool autofocus = false,
    bool autocorrect = true,
    double cursorWidth = 2.0,
    double? cursorHeight,
    TextInputType? keyboardType,
    TextStyle? style,
    TextEditingController? controller,
    TextInputAction? textInputAction,
    StrutStyle? strutStyle,
    TextDirection? textDirection,
    int? maxLength,
    void Function()? onEditingComplete,
    void Function(String?)? onSubmitted,
    List<TextInputFormatter>? inputFormatters,
    Radius? cursorRadius,
    Color? cursorColor,
    Brightness? keyboardAppearance,
    Widget Function(BuildContext,
            {required int currentLength,
            required bool isFocused,
            required int? maxLength})?
        buildCounter,
    bool expands = false,
    int? minLines,
    bool? showCursor,
    void Function()? onTap,
    void Function(PointerDownEvent)? onTapOutside,
    bool enableSuggestions = false,
    TextAlignVertical? textAlignVertical,
    DragStartBehavior dragStartBehavior = DragStartBehavior.start,
    ScrollController? scrollController,
    ScrollPhysics? scrollPhysics,
    BoxWidthStyle selectionWidthStyle = BoxWidthStyle.tight,
    SmartDashesType? smartDashesType,
    SmartQuotesType? smartQuotesType,
    BoxHeightStyle selectionHeightStyle = BoxHeightStyle.tight,
    Iterable<String>? autofillHints,
    String obscuringCharacter = '•',
    MouseCursor? mouseCursor,
    Widget Function(BuildContext, EditableTextState)? contextMenuBuilder,
    TextMagnifierConfiguration? magnifierConfiguration,
    ContentInsertionConfiguration? contentInsertionConfiguration,
    SpellCheckConfiguration? spellCheckConfiguration, 
  }) : super(
          key: key,
          name: name,
          validator: validator,
          decoration: decoration,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          enabled: enabled,
          onSaved: onSaved,
          autovalidateMode: autovalidateMode,
          onReset: onReset,
          focusNode: focusNode,
          restorationId: restorationId,
          initialValue: initialValue,
          readOnly: readOnly,
          maxLines: maxLines,
          obscureText: obscureText,
          textCapitalization: textCapitalization,
          scrollPadding: scrollPadding,
          enableInteractiveSelection: enableInteractiveSelection,
          maxLengthEnforcement: maxLengthEnforcement,
          textAlign: textAlign,
          autofocus: autofocus,
          autocorrect: autocorrect,
          cursorWidth: cursorWidth,
          cursorHeight: cursorHeight,
          keyboardType: keyboardType,
          style: style,
          controller: controller,
          textInputAction: textInputAction,
          strutStyle: strutStyle,
          textDirection: textDirection,
          maxLength: maxLength,
          onEditingComplete: onEditingComplete,
          onSubmitted: onSubmitted,
          inputFormatters: inputFormatters,
          cursorRadius: cursorRadius,
          cursorColor: cursorColor,
          keyboardAppearance: keyboardAppearance,
          buildCounter: buildCounter,
          expands: expands,
          minLines: minLines,
          showCursor: showCursor,
          onTap: onTap,
          onTapOutside: onTapOutside,
          enableSuggestions: enableSuggestions,
          textAlignVertical: textAlignVertical,
          dragStartBehavior: dragStartBehavior,
          scrollController: scrollController,
          scrollPhysics: scrollPhysics,
          selectionWidthStyle: selectionWidthStyle,
          smartDashesType: smartDashesType,
          smartQuotesType: smartQuotesType,
          selectionHeightStyle: selectionHeightStyle,
          autofillHints: autofillHints,
          obscuringCharacter: obscuringCharacter,
          mouseCursor: mouseCursor,
          contextMenuBuilder: contextMenuBuilder,
          magnifierConfiguration: magnifierConfiguration,
          contentInsertionConfiguration: contentInsertionConfiguration,
          spellCheckConfiguration: spellCheckConfiguration,
        );
}

class ProGridView extends GridView {
  // ignore: use_super_parameters
  ProGridView({
    Key? key,
    Axis scrollDirection = Axis.vertical,
    bool reverse = false,
    ScrollController? controller,
    bool? primary,
    ScrollPhysics? physics,
    bool shrinkWrap = false,
    EdgeInsetsGeometry? padding,
    required SliverGridDelegate gridDelegate,
    bool addAutomaticKeepAlives = true,
    bool addRepaintBoundaries = true,
    bool addSemanticIndexes = true,
    double? cacheExtent,
    List<Widget> children = const <Widget>[],
    int? semanticChildCount,
    Clip clipBehavior = Clip.hardEdge,
    ScrollViewKeyboardDismissBehavior keyboardDismissBehavior =
        ScrollViewKeyboardDismissBehavior.manual, required int itemCount, required Container Function(dynamic context, dynamic index) itemBuilder,
  }) : super(
          key: key,
          scrollDirection: scrollDirection,
          reverse: reverse,
          controller: controller,
          primary: primary,
          physics: physics,
          shrinkWrap: shrinkWrap,
          padding: padding,
          gridDelegate: gridDelegate,
          addAutomaticKeepAlives: addAutomaticKeepAlives,
          addRepaintBoundaries: addRepaintBoundaries,
          addSemanticIndexes: addSemanticIndexes,
          cacheExtent: cacheExtent,
          semanticChildCount: semanticChildCount,
          clipBehavior: clipBehavior,
          keyboardDismissBehavior: keyboardDismissBehavior,
          children: children,
        );
}
 

class ProLinearProgressIndicator extends LinearProgressIndicator {
  // ignore: use_super_parameters
  const ProLinearProgressIndicator({
    Key? key,
    double? value,
    Color? backgroundColor,
    Color? color,
    Animation<Color?>? valueColor,
    double? minHeight,
    String? semanticsLabel,
    String? semanticsValue,
    BorderRadiusGeometry borderRadius = BorderRadius.zero,
  }) : super(
          key: key,
          value: value,
          backgroundColor: backgroundColor,
          color: color,
          valueColor: valueColor,
          minHeight: minHeight,
          semanticsLabel: semanticsLabel,
          semanticsValue: semanticsValue,
          borderRadius: borderRadius,
        );
}

class ProCheckbox extends FormBuilderCheckbox {
  // ignore: use_super_parameters
  ProCheckbox({
    Key? key,
    required String name,
    String? Function(bool?)? validator,
    bool? initialValue,
    InputDecoration decoration = const InputDecoration(
      border: InputBorder.none,
      focusedBorder: InputBorder.none,
      enabledBorder: InputBorder.none,
      errorBorder: InputBorder.none,
      disabledBorder: InputBorder.none,
    ),
    void Function(bool?)? onChanged,
    dynamic Function(bool?)? valueTransformer,
    bool enabled = true,
    void Function(bool?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    required Widget title,
    Color? activeColor,
    bool autofocus = false,
    Color? checkColor,
    EdgeInsets contentPadding = EdgeInsets.zero,
    VisualDensity? visualDensity,
    ListTileControlAffinity controlAffinity = ListTileControlAffinity.leading,
    Widget? secondary,
    bool selected = false,
    Widget? subtitle,
    bool tristate = false,
    OutlinedBorder? shape,
    BorderSide? side,
  }) : super(
          key: key,
          name: name,
          validator: validator,
          initialValue: initialValue,
          decoration: decoration,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          enabled: enabled,
          onSaved: onSaved,
          autovalidateMode: autovalidateMode,
          onReset: onReset,
          focusNode: focusNode,
          restorationId: restorationId,
          title: title,
          activeColor: activeColor,
          autofocus: autofocus,
          checkColor: checkColor,
          contentPadding: contentPadding,
          visualDensity: visualDensity,
          controlAffinity: controlAffinity,
          secondary: secondary,
          selected: selected,
          subtitle: subtitle,
          tristate: tristate,
          shape: shape,
          side: side,
        );
}

class ProCheckboxGroup extends FormBuilderCheckboxGroup {
  // ignore: use_super_parameters
  ProCheckboxGroup({
    Key? key,
    required String name,
    VisualDensity? visualDensity,
    String? Function(List<dynamic>?)? validator,
    List<dynamic>? initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(List<dynamic>?)? onChanged,
    dynamic Function(List<dynamic>?)? valueTransformer,
    bool enabled = true,
    void Function(List<dynamic>?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    required List<FormBuilderFieldOption<dynamic>> options,
    Color? activeColor,
    Color? checkColor,
    Color? focusColor,
    Color? hoverColor,
    List<dynamic>? disabled,
    MaterialTapTargetSize? materialTapTargetSize,
    bool tristate = false,
    Axis wrapDirection = Axis.horizontal,
    WrapAlignment wrapAlignment = WrapAlignment.start,
    double wrapSpacing = 0.0,
    WrapAlignment wrapRunAlignment = WrapAlignment.start,
    double wrapRunSpacing = 0.0,
    WrapCrossAlignment wrapCrossAxisAlignment = WrapCrossAlignment.start,
    TextDirection? wrapTextDirection,
    VerticalDirection wrapVerticalDirection = VerticalDirection.down,
    Widget? separator,
    ControlAffinity controlAffinity = ControlAffinity.leading,
    OptionsOrientation orientation = OptionsOrientation.wrap,
    BoxDecoration? itemDecoration,
    required List selectedOptions,
  }) : super(
          key: key,
          name: name,
          visualDensity: visualDensity,
          validator: validator,
          initialValue: initialValue,
          decoration: decoration,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          enabled: enabled,
          onSaved: onSaved,
          autovalidateMode: autovalidateMode,
          onReset: onReset,
          focusNode: focusNode,
          restorationId: restorationId,
          options: options,
          activeColor: activeColor,
          checkColor: checkColor,
          focusColor: focusColor,
          hoverColor: hoverColor,
          disabled: disabled,
          materialTapTargetSize: materialTapTargetSize,
          tristate: tristate,
          wrapDirection: wrapDirection,
          wrapAlignment: wrapAlignment,
          wrapSpacing: wrapSpacing,
          wrapRunAlignment: wrapRunAlignment,
          wrapRunSpacing: wrapRunSpacing,
          wrapCrossAxisAlignment: wrapCrossAxisAlignment,
          wrapTextDirection: wrapTextDirection,
          wrapVerticalDirection: wrapVerticalDirection,
          separator: separator,
          controlAffinity: controlAffinity,
          orientation: orientation,
          itemDecoration: itemDecoration,
        );
}

class ProChoiceChip extends FormBuilderChoiceChip<dynamic> {
  // ignore: use_super_parameters
  ProChoiceChip({
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    bool enabled = true,
    FocusNode? focusNode,
    void Function(dynamic)? onSaved,
    String? Function(dynamic)? validator,
    InputDecoration decoration = const InputDecoration(),
    Key? key,
    required String name,
    required List<FormBuilderChipOption<dynamic>> options,
    dynamic initialValue,
    String? restorationId,
    void Function(dynamic)? onChanged,
    dynamic Function(dynamic)? valueTransformer,
    void Function()? onReset,
    WrapAlignment alignment = WrapAlignment.start,
    ShapeBorder avatarBorder = const CircleBorder(),
    Color? backgroundColor,
    WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start,
    Axis direction = Axis.horizontal,
    Color? disabledColor,
    double? elevation,
    EdgeInsets? labelPadding,
    TextStyle? labelStyle,
    MaterialTapTargetSize? materialTapTargetSize,
    EdgeInsets? padding,
    double? pressElevation,
    WrapAlignment runAlignment = WrapAlignment.start,
    double runSpacing = 0.0,
    Color? selectedColor,
    Color? selectedShadowColor,
    Color? shadowColor,
    OutlinedBorder? shape,
    double spacing = 0.0,
    TextDirection? textDirection,
    VerticalDirection verticalDirection = VerticalDirection.down,
    VisualDensity? visualDensity,
     required selectedValues,
  }) : super(
          autovalidateMode: autovalidateMode,
          enabled: enabled,
          focusNode: focusNode,
          onSaved: onSaved,
          validator: validator,
          decoration: decoration,
          key: key,
          name: name,
          options: options,
          initialValue: initialValue,
          restorationId: restorationId,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          onReset: onReset,
          alignment: alignment,
          avatarBorder: avatarBorder,
          backgroundColor: backgroundColor,
          crossAxisAlignment: crossAxisAlignment,
          direction: direction,
          disabledColor: disabledColor,
          elevation: elevation,
          labelPadding: labelPadding,
          labelStyle: labelStyle,
          materialTapTargetSize: materialTapTargetSize,
          padding: padding,
          pressElevation: pressElevation,
          runAlignment: runAlignment,
          runSpacing: runSpacing,
          selectedColor: selectedColor,
          selectedShadowColor: selectedShadowColor,
          shadowColor: shadowColor,
          shape: shape,
          spacing: spacing,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          visualDensity: visualDensity,
        );
}

class ProDateRangePicker extends FormBuilderDateRangePicker {
  // ignore: use_super_parameters
  ProDateRangePicker({
    Key? key,
    required String name,
    String? Function(DateTimeRange?)? validator,
    DateTimeRange? initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(DateTimeRange?)? onChanged,
    dynamic Function(DateTimeRange?)? valueTransformer,
    bool enabled = true,
    void Function(DateTimeRange?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    required DateTime firstDate,
    required DateTime lastDate,
    DateFormat? format,
    int maxLines = 1,
    bool obscureText = false,
    TextCapitalization textCapitalization = TextCapitalization.none,
    EdgeInsets scrollPadding = const EdgeInsets.all(20.0),
    bool enableInteractiveSelection = true,
    MaxLengthEnforcement? maxLengthEnforcement,
    TextAlign textAlign = TextAlign.start,
    TextAlignVertical? textAlignVertical,
    bool autofocus = false,
    bool autocorrect = true,
    double cursorWidth = 2.0,
    TextInputType? keyboardType,
    TextStyle? style,
    TextEditingController? controller,
    TextInputAction? textInputAction,
    StrutStyle? strutStyle,
    TextDirection? textDirection,
    int? maxLength,
    void Function()? onEditingComplete,
    void Function(DateTimeRange?)? onFieldSubmitted,
    List<TextInputFormatter>? inputFormatters,
    Radius? cursorRadius,
    Color? cursorColor,
    Brightness? keyboardAppearance,
    Widget? Function(BuildContext,
            {required int currentLength,
            required bool isFocused,
            required int? maxLength})?
        buildCounter,
    MouseCursor? mouseCursor,
    bool expands = false,
    int? minLines,
    bool showCursor = false,
    Locale? locale,
    String? cancelText,
    String? confirmText,
    DateTime? currentDate,
    String? errorFormatText,
    Widget Function(BuildContext, Widget?)? pickerBuilder,
    String? errorInvalidRangeText,
    String? errorInvalidText,
    String? fieldEndHintText,
    String? fieldEndLabelText,
    String? fieldStartHintText,
    String? fieldStartLabelText,
    String? helpText,
    DatePickerEntryMode initialEntryMode = DatePickerEntryMode.calendar,
    RouteSettings? routeSettings,
    String? saveText,
    bool useRootNavigator = true,
    bool allowClear = false,
    Widget? clearIcon, 
    required Null Function(dynamic dateRange) onDateRangeSelected,
  }) : super(
          key: key,
          name: name,
          validator: validator,
          initialValue: initialValue,
          decoration: decoration,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          enabled: enabled,
          onSaved: onSaved,
          autovalidateMode: autovalidateMode,
          onReset: onReset,
          focusNode: focusNode,
          restorationId: restorationId,
          firstDate: firstDate,
          lastDate: lastDate,
          format: format,
          maxLines: maxLines,
          obscureText: obscureText,
          textCapitalization: textCapitalization,
          scrollPadding: scrollPadding,
          enableInteractiveSelection: enableInteractiveSelection,
          maxLengthEnforcement: maxLengthEnforcement,
          textAlign: textAlign,
          textAlignVertical: textAlignVertical,
          autofocus: autofocus,
          autocorrect: autocorrect,
          cursorWidth: cursorWidth,
          keyboardType: keyboardType,
          style: style,
          controller: controller,
          textInputAction: textInputAction,
          strutStyle: strutStyle,
          textDirection: textDirection,
          maxLength: maxLength,
          onEditingComplete: onEditingComplete,
          onFieldSubmitted: onFieldSubmitted,
          inputFormatters: inputFormatters,
          cursorRadius: cursorRadius,
          cursorColor: cursorColor,
          keyboardAppearance: keyboardAppearance,
          buildCounter: buildCounter,
          mouseCursor: mouseCursor,
          expands: expands,
          minLines: minLines,
          showCursor: showCursor,
          locale: locale,
          cancelText: cancelText,
          confirmText: confirmText,
          currentDate: currentDate,
          errorFormatText: errorFormatText,
          pickerBuilder: pickerBuilder,
          errorInvalidRangeText: errorInvalidRangeText,
          errorInvalidText: errorInvalidText,
          fieldEndHintText: fieldEndHintText,
          fieldEndLabelText: fieldEndLabelText,
          fieldStartHintText: fieldStartHintText,
          fieldStartLabelText: fieldStartLabelText,
          helpText: helpText,
          initialEntryMode: initialEntryMode,
          routeSettings: routeSettings,
          saveText: saveText,
          useRootNavigator: useRootNavigator,
          allowClear: allowClear,
          clearIcon: clearIcon,
        );
}

class ProDateTimePicker extends FormBuilderDateTimePicker {
  // ignore: use_super_parameters
  ProDateTimePicker({
    Key? key,
    required String name,
    String? Function(DateTime?)? validator,
    DateTime? initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(DateTime?)? onChanged,
    dynamic Function(DateTime?)? valueTransformer,
    bool enabled = true,
    void Function(DateTime?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    InputType inputType = InputType.both,
    EdgeInsets scrollPadding = const EdgeInsets.all(20.0),
    double cursorWidth = 2.0,
    bool enableInteractiveSelection = true,
    Widget? resetIcon = const Icon(Icons.close),
    TimeOfDay initialTime = const TimeOfDay(hour: 12, minute: 0),
    TextInputType? keyboardType,
    TextAlign textAlign = TextAlign.start,
    bool autofocus = false,
    bool obscureText = false,
    bool autocorrect = true,
    int? maxLines = 1,
    bool expands = false,
    DatePickerMode initialDatePickerMode = DatePickerMode.day,
    Widget Function(BuildContext, Widget?)? transitionBuilder,
    TextCapitalization textCapitalization = TextCapitalization.none,
    bool useRootNavigator = true,
    DatePickerEntryMode initialEntryMode = DatePickerEntryMode.calendar,
    TimePickerEntryMode timePickerInitialEntryMode = TimePickerEntryMode.dial,
    DateFormat? format,
    DateTime? initialDate,
    DateTime? firstDate,
    DateTime? lastDate,
    DateTime? currentDate,
    Locale? locale,
    int? maxLength,
    TextDirection? textDirection,
    TextAlignVertical? textAlignVertical,
    void Function(DateTime?)? onFieldSubmitted,
    TextEditingController? controller,
    TextStyle? style,
    MaxLengthEnforcement maxLengthEnforcement = MaxLengthEnforcement.none,
    List<TextInputFormatter>? inputFormatters,
    bool showCursor = false,
    int? minLines,
    TextInputAction? textInputAction,
    void Function()? onEditingComplete,
    Widget? Function(BuildContext,
            {required int currentLength,
            required bool isFocused,
            required int? maxLength})?
        buildCounter,
    MouseCursor? mouseCursor,
    Radius? cursorRadius,
    Color? cursorColor,
    Brightness? keyboardAppearance,
    String? cancelText,
    String? confirmText,
    String? errorFormatText,
    String? errorInvalidText,
    String? fieldHintText,
    String? fieldLabelText,
    String? helpText,
    RouteSettings? routeSettings,
    StrutStyle? strutStyle,
    bool Function(DateTime)? selectableDayPredicate,
    Offset? anchorPoint,
    void Function(TimePickerEntryMode)? onEntryModeChanged, 
    required EdgeInsets margin, 
    required ProText child, 
    required Null Function(dynamic dateTime) onDaterTimeSelected,
  }) : super(
          key: key,
          name: name,
          validator: validator,
          initialValue: initialValue,
          decoration: decoration,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          enabled: enabled,
          onSaved: onSaved,
          autovalidateMode: autovalidateMode,
          onReset: onReset,
          focusNode: focusNode,
          restorationId: restorationId,
          inputType: inputType,
          scrollPadding: scrollPadding,
          cursorWidth: cursorWidth,
          enableInteractiveSelection: enableInteractiveSelection,
          resetIcon: resetIcon,
          initialTime: initialTime,
          keyboardType: keyboardType,
          textAlign: textAlign,
          autofocus: autofocus,
          obscureText: obscureText,
          maxLines: maxLines,
          expands: expands,
          initialDatePickerMode: initialDatePickerMode,
          transitionBuilder: transitionBuilder,
          textCapitalization: textCapitalization,
          useRootNavigator: useRootNavigator,
          initialEntryMode: initialEntryMode,
          timePickerInitialEntryMode: timePickerInitialEntryMode,
          format: format,
          initialDate: initialDate,
          firstDate: firstDate,
          lastDate: lastDate,
          currentDate: currentDate,
          locale: locale,
          maxLength: maxLength,
          textDirection: textDirection,
          textAlignVertical: textAlignVertical,
          onFieldSubmitted: onFieldSubmitted,
          controller: controller,
          style: style,
          maxLengthEnforcement: maxLengthEnforcement,
          inputFormatters: inputFormatters,
          showCursor: showCursor,
          minLines: minLines,
          textInputAction: textInputAction,
          onEditingComplete: onEditingComplete,
          buildCounter: buildCounter,
          mouseCursor: mouseCursor,
          cursorRadius: cursorRadius,
          cursorColor: cursorColor,
          keyboardAppearance: keyboardAppearance,
          cancelText: cancelText,
          confirmText: confirmText,
          errorFormatText: errorFormatText,
          errorInvalidText: errorInvalidText,
          fieldHintText: fieldHintText,
          fieldLabelText: fieldLabelText,
          helpText: helpText,
          routeSettings: routeSettings,
          strutStyle: strutStyle,
          selectableDayPredicate: selectableDayPredicate,
          anchorPoint: anchorPoint,
          onEntryModeChanged: onEntryModeChanged,
        );
}

class ProDropdown extends FormBuilderDropdown {
  // ignore: use_super_parameters
  ProDropdown({
    Key? key,
    required String name,
    String? Function(dynamic)? validator,
    dynamic initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(dynamic)? onChanged,
    dynamic Function(dynamic)? valueTransformer,
    bool enabled = true,
    void Function(dynamic)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    required List<DropdownMenuItem<dynamic>> items,
    bool isExpanded = true,
    bool isDense = true,
    int elevation = 8,
    double iconSize = 24.0,
    TextStyle? style,
    Widget? disabledHint,
    Widget? icon,
    Color? iconDisabledColor,
    Color? iconEnabledColor,
    void Function()? onTap,
    bool autofocus = false,
    Color? dropdownColor,
    Color? focusColor,
    double? itemHeight,
    List<Widget> Function(BuildContext)? selectedItemBuilder,
    double? menuMaxHeight,
    bool? enableFeedback,
    BorderRadius? borderRadius,
    AlignmentGeometry alignment = AlignmentDirectional.centerStart, 
    required String hint, 
    required padding,
  }) : super(
          key: key,
          name: name,
          validator: validator,
          initialValue: initialValue,
          decoration: decoration,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          enabled: enabled,
          onSaved: onSaved,
          autovalidateMode: autovalidateMode,
          onReset: onReset,
          focusNode: focusNode,
          restorationId: restorationId,
          items: items,
          isExpanded: isExpanded,
          isDense: isDense,
          elevation: elevation,
          iconSize: iconSize,
          style: style,
          disabledHint: disabledHint,
          icon: icon,
          iconDisabledColor: iconDisabledColor,
          iconEnabledColor: iconEnabledColor,
          onTap: onTap,
          autofocus: autofocus,
          dropdownColor: dropdownColor,
          focusColor: focusColor,
          itemHeight: itemHeight,
          selectedItemBuilder: selectedItemBuilder,
          menuMaxHeight: menuMaxHeight,
          enableFeedback: enableFeedback,
          borderRadius: borderRadius,
          alignment: alignment,
        );
}

class ProFilterChip extends FormBuilderFilterChip {
  // ignore: use_super_parameters
  ProFilterChip({
    Key? key,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    bool enabled = true,
    FocusNode? focusNode,
    void Function(List<dynamic>?)? onSaved,
    String? Function(List<dynamic>?)? validator,
    InputDecoration decoration = const InputDecoration(),
    List<dynamic>? initialValue,
    required String name,
    String? restorationId,
    required List<FormBuilderChipOption<dynamic>> options,
    WrapAlignment alignment = WrapAlignment.start,
    ShapeBorder avatarBorder = const CircleBorder(),
    Color? backgroundColor,
    Color? checkmarkColor,
    Clip clipBehavior = Clip.none,
    WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start,
    Axis direction = Axis.horizontal,
    Color? disabledColor,
    double? elevation,
    EdgeInsets? labelPadding,
    TextStyle? labelStyle,
    MaterialTapTargetSize? materialTapTargetSize,
    int? maxChips,
    EdgeInsets? padding,
    double? pressElevation,
    WrapAlignment runAlignment = WrapAlignment.start,
    double runSpacing = 0.0,
    Color? selectedColor,
    Color? selectedShadowColor,
    Color? shadowColor,
    OutlinedBorder? shape,
    bool showCheckmark = true,
    double spacing = 0.0,
    TextDirection? textDirection,
    VerticalDirection verticalDirection = VerticalDirection.down,
    void Function(List<dynamic>?)? onChanged,
    dynamic Function(List<dynamic>?)? valueTransformer,
    void Function()? onReset, 
    required Null Function(bool isSelected) OnSelected, 
    required bool selected,
    required Icon avatar,
  }) : super(
          key: key,
          autovalidateMode: autovalidateMode,
          enabled: enabled,
          focusNode: focusNode,
          onSaved: onSaved,
          validator: validator,
          decoration: decoration,
          initialValue: initialValue,
          name: name,
          restorationId: restorationId,
          options: options,
          alignment: alignment,
          avatarBorder: avatarBorder,
          backgroundColor: backgroundColor,
          checkmarkColor: checkmarkColor,
          clipBehavior: clipBehavior,
          crossAxisAlignment: crossAxisAlignment,
          direction: direction,
          disabledColor: disabledColor,
          elevation: elevation,
          labelPadding: labelPadding,
          labelStyle: labelStyle,
          materialTapTargetSize: materialTapTargetSize,
          maxChips: maxChips,
          padding: padding,
          pressElevation: pressElevation,
          runAlignment: runAlignment,
          runSpacing: runSpacing,
          selectedColor: selectedColor,
          selectedShadowColor: selectedShadowColor,
          shadowColor: shadowColor,
          shape: shape,
          showCheckmark: showCheckmark,
          spacing: spacing,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          onReset: onReset,
        );
}

class ProRadioGroup extends FormBuilderRadioGroup<dynamic> {
  ProRadioGroup({
    Key? key,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    bool enabled = true,
    FocusNode? focusNode,
    void Function(dynamic)? onSaved,
    String? Function(dynamic)? validator,
    InputDecoration decoration = const InputDecoration(),
    required String name,
    required List<FormBuilderFieldOption<dynamic>> options,
    dynamic initialValue,
    Color? activeColor,
    ControlAffinity controlAffinity = ControlAffinity.leading,
    List<dynamic>? disabled,
    Color? focusColor,
    Color? hoverColor,
    MaterialTapTargetSize? materialTapTargetSize,
    OptionsOrientation orientation = OptionsOrientation.wrap,
    Widget? separator,
    WrapAlignment wrapAlignment = WrapAlignment.start,
    WrapCrossAlignment wrapCrossAxisAlignment = WrapCrossAlignment.start,
    Axis wrapDirection = Axis.horizontal,
    WrapAlignment wrapRunAlignment = WrapAlignment.start,
    double wrapRunSpacing = 0.0,
    double wrapSpacing = 0.0,
    TextDirection? wrapTextDirection,
    VerticalDirection wrapVerticalDirection = VerticalDirection.down,
    void Function(dynamic)? onChanged,
    dynamic Function(dynamic)? valueTransformer,
    void Function()? onReset,
    String? restorationId,
    BoxDecoration? itemDecoration, 
    required Axis direction, 
    required TextStyle textStyle,
  }) : super(
          key: key,
          autovalidateMode: autovalidateMode,
          enabled: enabled,
          focusNode: focusNode,
          onSaved: onSaved,
          validator: validator,
          decoration: decoration,
          name: name,
          options: options,
          initialValue: initialValue,
          activeColor: activeColor,
          controlAffinity: controlAffinity,
          disabled: disabled,
          focusColor: focusColor,
          hoverColor: hoverColor,
          materialTapTargetSize: materialTapTargetSize,
          orientation: orientation,
          separator: separator,
          wrapAlignment: wrapAlignment,
          wrapCrossAxisAlignment: wrapCrossAxisAlignment,
          wrapDirection: wrapDirection,
          wrapRunAlignment: wrapRunAlignment,
          wrapRunSpacing: wrapRunSpacing,
          wrapSpacing: wrapSpacing,
          wrapTextDirection: wrapTextDirection,
          wrapVerticalDirection: wrapVerticalDirection,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          onReset: onReset,
          restorationId: restorationId,
          itemDecoration: itemDecoration,
        );
}

class ProRangeSlider extends FormBuilderRangeSlider {
  // ignore: use_super_parameters
  ProRangeSlider({
    Key? key,
    required String name,
    String? Function(RangeValues?)? validator,
    RangeValues? initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(RangeValues?)? onChanged,
    dynamic Function(RangeValues?)? valueTransformer,
    bool enabled = true,
    void Function(RangeValues?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    required double min,
    required double max,
    int? divisions,
    Color? activeColor,
    Color? inactiveColor,
    void Function(RangeValues)? onChangeStart,
    void Function(RangeValues)? onChangeEnd,
    RangeLabels? labels,
    String Function(double)? semanticFormatterCallback,
    DisplayValues displayValues = DisplayValues.all,
    Widget Function(String)? minValueWidget,
    Widget Function(String)? valueWidget,
    Widget Function(String)? maxValueWidget,
    NumberFormat? numberFormat, 
    required int lowerValue, 
    required int upperValue,
    required MaterialColor thumbColor, 
    required int thumbRadius, 
    required int thumbStrokeWidth, 
    required Icon leftchild, 
    required Icon rightchild, 
    required Color thumbStrokeColor,
  }) : super(
          key: key,
          name: name,
          validator: validator,
          initialValue: initialValue,
          decoration: decoration,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          enabled: enabled,
          onSaved: onSaved,
          autovalidateMode: autovalidateMode,
          onReset: onReset,
          focusNode: focusNode,
          min: min,
          max: max,
          divisions: divisions,
          activeColor: activeColor,
          inactiveColor: inactiveColor,
          onChangeStart: onChangeStart,
          onChangeEnd: onChangeEnd,
          labels: labels,
          semanticFormatterCallback: semanticFormatterCallback,
          displayValues: displayValues,
          minValueWidget: minValueWidget,
          valueWidget: valueWidget,
          maxValueWidget: maxValueWidget,
          numberFormat: numberFormat,
        );
}

class ProSlider extends FormBuilderSlider {
  // ignore: use_super_parameters
  ProSlider({
    Key? key,
    required String name,
    String? Function(double?)? validator,
    required double initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(double?)? onChanged,
    dynamic Function(double?)? valueTransformer,
    bool enabled = true,
    void Function(double?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    required double min,
    required double max,
    int? divisions,
    Color? activeColor,
    Color? inactiveColor,
    void Function(double)? onChangeStart,
    void Function(double)? onChangeEnd,
    String? label,
    String Function(double)? semanticFormatterCallback,
    NumberFormat? numberFormat,
    DisplayValues displayValues = DisplayValues.all,
    bool autofocus = false,
    MouseCursor? mouseCursor,
    Widget Function(String)? maxValueWidget,
    Widget Function(String)? minValueWidget,
    Widget Function(String)? valueWidget, 
    required int thumbStrokeWidth,
    required int thumbRadius, 
   required Color thumbColor,
  }) : super(
          key: key,
          name: name,
          validator: validator,
          initialValue: initialValue,
          decoration: decoration,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          enabled: enabled,
          onSaved: onSaved,
          autovalidateMode: autovalidateMode,
          onReset: onReset,
          focusNode: focusNode,
          restorationId: restorationId,
          min: min,
          max: max,
          divisions: divisions,
          activeColor: activeColor,
          inactiveColor: inactiveColor,
          onChangeStart: onChangeStart,
          onChangeEnd: onChangeEnd,
          label: label,
          semanticFormatterCallback: semanticFormatterCallback,
          numberFormat: numberFormat,
          displayValues: displayValues,
          autofocus: autofocus,
          mouseCursor: mouseCursor,
          maxValueWidget: maxValueWidget,
          minValueWidget: minValueWidget,
          valueWidget: valueWidget,
        );
}

class ProSwitch extends FormBuilderSwitch {
  // ignore: use_super_parameters
  ProSwitch({
    Key? key,
    required String name,
    String? Function(bool?)? validator,
    bool? initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(bool?)? onChanged,
    dynamic Function(bool?)? valueTransformer,
    bool enabled = true,
    void Function(bool?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    required Widget title,
    Color? activeColor,
    Color? activeTrackColor,
    Color? inactiveThumbColor,
    Color? inactiveTrackColor,
    ImageProvider<Object>? activeThumbImage,
    ImageProvider<Object>? inactiveThumbImage,
    Widget? subtitle,
    Widget? secondary,
    ListTileControlAffinity controlAffinity = ListTileControlAffinity.trailing,
    EdgeInsets contentPadding = EdgeInsets.zero,
    bool autofocus = false,
    bool selected = false, 
    required bool value,
    required MaterialColor inactiveColor,
    required Color thumbColor, 
    required int thumbRadius, 
    required MaterialColor thumbStrokeColor,
    required int thumbStrokeWidth,
  }) : super(
          key: key,
          name: name,
          validator: validator,
          initialValue: initialValue,
          decoration: decoration,
          onChanged: onChanged,
          valueTransformer: valueTransformer,
          enabled: enabled,
          onSaved: onSaved,
          autovalidateMode: autovalidateMode,
          onReset: onReset,
          focusNode: focusNode,
          restorationId: restorationId,
          title: title,
          activeColor: activeColor,
          activeTrackColor: activeTrackColor,
          inactiveTrackColor: inactiveTrackColor,
          activeThumbImage: activeThumbImage,
          inactiveThumbImage: inactiveThumbImage,
          subtitle: subtitle,
          secondary: secondary,
          controlAffinity: controlAffinity,
          contentPadding: contentPadding,
          autofocus: autofocus,
          selected: selected,
        );
}

class BaseWidgets {
  //Method to create a image.asset
  static Image proImageAsset({
    required String name,
    Key? key,
    AssetBundle? bundle,
    Widget Function(BuildContext, Widget, int?, bool)? frameBuilder,
    Widget Function(BuildContext, Object, StackTrace?)? errorBuilder,
    String? semanticLabel,
    bool excludeFromSemantics = false,
    double? scale,
    double? width,
    double? height,
    Color? color,
    Animation<double>? opacity,
    BlendMode? colorBlendMode,
    BoxFit? fit,
    AlignmentGeometry alignment = Alignment.center,
    ImageRepeat repeat = ImageRepeat.noRepeat,
    Rect? centerSlice,
    bool matchTextDirection = false,
    bool gaplessPlayback = false,
    bool isAntiAlias = false,
    String? package,
    FilterQuality filterQuality = FilterQuality.low,
    int? cacheWidth,
    int? cacheHeight,
  }) {
    return Image.asset(
      name,
      key: key,
      bundle: bundle,
      frameBuilder: frameBuilder,
      errorBuilder: errorBuilder,
      semanticLabel: semanticLabel,
      excludeFromSemantics: excludeFromSemantics,
      scale: scale,
      width: width,
      height: height,
      color: color,
      opacity: opacity,
      colorBlendMode: colorBlendMode,
      fit: fit,
      alignment: alignment,
      repeat: repeat,
      centerSlice: centerSlice,
      matchTextDirection: matchTextDirection,
      gaplessPlayback: gaplessPlayback,
      isAntiAlias: isAntiAlias,
      package: package,
      filterQuality: filterQuality,
      cacheWidth: cacheWidth,
      cacheHeight: cacheHeight,
    );
  }

  //Method to create a image.file
  static Image proImageFile(
      {required file,
      Key? key,
      double scale = 1.0,
      ImageFrameBuilder? frameBuilder,
      ImageErrorWidgetBuilder? errorBuilder,
      String? semanticLabel,
      bool excludeFromSemantics = false,
      double? width,
      double? height,
      Color? color,
      Animation<double>? opacity,
      BlendMode? colorBlendMode,
      BoxFit? fit,
      AlignmentGeometry alignment = Alignment.center,
      ImageRepeat repeat = ImageRepeat.noRepeat,
      Rect? centerSlice,
      bool matchTextDirection = false,
      bool gaplessPlayback = false,
      bool isAntiAlias = false,
      FilterQuality filterQuality = FilterQuality.low,
      int? cacheWidth,
      int? cacheHeight}) {
    return Image.file(
      file,
      key: key,
      scale: scale,
      frameBuilder: frameBuilder,
      errorBuilder: errorBuilder,
      semanticLabel: semanticLabel,
      excludeFromSemantics: excludeFromSemantics,
      width: width,
      height: height,
      color: color,
      opacity: opacity,
      colorBlendMode: colorBlendMode,
      fit: fit,
      alignment: alignment,
      repeat: repeat,
      centerSlice: centerSlice,
      matchTextDirection: matchTextDirection,
      gaplessPlayback: gaplessPlayback,
      isAntiAlias: isAntiAlias,
      filterQuality: filterQuality,
      cacheWidth: cacheWidth,
      cacheHeight: cacheHeight,
    );
  }

  //Method to create an image.memory
  static Image proImageMemory(
      {required bytes,
      Key? key,
      double scale = 1.0,
      ImageFrameBuilder? frameBuilder,
      ImageErrorWidgetBuilder? errorBuilder,
      String? semanticLabel,
      bool excludeFromSemantics = false,
      double? width,
      double? height,
      Color? color,
      Animation<double>? opacity,
      BlendMode? colorBlendMode,
      BoxFit? fit,
      AlignmentGeometry alignment = Alignment.center,
      ImageRepeat repeat = ImageRepeat.noRepeat,
      Rect? centerSlice,
      bool matchTextDirection = false,
      bool gaplessPlayback = false,
      bool isAntiAlias = false,
      FilterQuality filterQuality = FilterQuality.low,
      int? cacheWidth,
      int? cacheHeight}) {
    return Image.memory(
      bytes,
      scale: scale,
      frameBuilder: frameBuilder,
      errorBuilder: errorBuilder,
      semanticLabel: semanticLabel,
      excludeFromSemantics: excludeFromSemantics,
      width: width,
      height: height,
      color: color,
      opacity: opacity,
      colorBlendMode: colorBlendMode,
      fit: fit,
      alignment: alignment,
      repeat: repeat,
      centerSlice: centerSlice,
      matchTextDirection: matchTextDirection,
      gaplessPlayback: gaplessPlayback,
      isAntiAlias: isAntiAlias,
      filterQuality: filterQuality,
      cacheWidth: cacheWidth,
      cacheHeight: cacheHeight,
    );
  }

  //Method to create an image.network
  static Image proImageNetwork(
      {required String src,
      Key? key,
      double scale = 1.0,
      Widget Function(BuildContext, Widget, int?, bool)? frameBuilder,
      Widget Function(BuildContext, Widget, ImageChunkEvent?)? loadingBuilder,
      Widget Function(BuildContext, Object, StackTrace?)? errorBuilder,
      String? semanticLabel,
      bool excludeFromSemantics = false,
      double? width,
      double? height,
      Color? color,
      Animation<double>? opacity,
      BlendMode? colorBlendMode,
      BoxFit? fit,
      AlignmentGeometry alignment = Alignment.center,
      ImageRepeat repeat = ImageRepeat.noRepeat,
      Rect? centerSlice,
      bool matchTextDirection = false,
      bool gaplessPlayback = false,
      FilterQuality filterQuality = FilterQuality.low,
      bool isAntiAlias = false,
      Map<String, String>? headers,
      int? cacheWidth,
      int? cacheHeight}) {
    return Image.network(
      src,
      scale: scale,
      frameBuilder: frameBuilder,
      loadingBuilder: loadingBuilder,
      errorBuilder: errorBuilder,
      semanticLabel: semanticLabel,
      excludeFromSemantics: excludeFromSemantics,
      width: width,
      height: height,
      color: color,
      opacity: opacity,
      colorBlendMode: colorBlendMode,
      fit: fit,
      alignment: alignment,
      repeat: repeat,
      centerSlice: centerSlice,
      matchTextDirection: matchTextDirection,
      gaplessPlayback: gaplessPlayback,
      filterQuality: filterQuality,
      isAntiAlias: isAntiAlias,
      headers: headers,
      cacheWidth: cacheWidth,
      cacheHeight: cacheHeight,
    );
  }
}



/*
// OLD///////////////////////////////////////////////////////////

// add button...
//Method to create a elevatedbutton
/*
  ElevatedButton proElevatedButton({
    required void Function()? onPressed,
    void Function()? onLongPress,
    void Function(bool)? onHover,
    void Function(bool)? onFocusChange,
    ButtonStyle? style,
    FocusNode? focusNode,
    bool autofocus = false,
    Clip clipBehavior = Clip.none,
    required Widget child,
  }) {
    return ElevatedButton(
      onPressed: onPressed,
      onLongPress: onLongPress,
      onHover: onHover,
      onFocusChange: onFocusChange,
      style: style,
      focusNode: focusNode,
      autofocus: autofocus,
      clipBehavior: clipBehavior,
      child: child,
    );
  }

  //Method to create a textbutton
  static TextButton proTextButton({
    required void Function()? onPressed,
    void Function()? onLongPress,
    void Function(bool)? onHover,
    void Function(bool)? onFocusChange,
    ButtonStyle? style,
    FocusNode? focusNode,
    bool autofocus = false,
    Clip clipBehavior = Clip.none,
    required Widget child,
    required TextAlign textAlign,
    required TextDirection textDirection,
  }) {
    return TextButton(
      onPressed: onPressed,
      onLongPress: onLongPress,
      onHover: onHover,
      onFocusChange: onFocusChange,
      style: style,
      focusNode: focusNode,
      autofocus: autofocus,
      clipBehavior: clipBehavior,
      child: child,
    );
  }

  //add image...
  static Image proImage({
    Key? key,
    required ImageProvider<Object> image,
    Widget Function(BuildContext, Widget, int?, bool)? frameBuilder,
    Widget Function(BuildContext, Widget, ImageChunkEvent?)? loadingBuilder,
    Widget Function(BuildContext, Object, StackTrace?)? errorBuilder,
    String? semanticLabel,
    bool excludeFromSemantics = false,
    double? width,
    double? height,
    Color? color,
    Animation<double>? opacity,
    BlendMode? colorBlendMode,
    BoxFit? fit,
    AlignmentGeometry alignment = Alignment.center,
    ImageRepeat repeat = ImageRepeat.noRepeat,
    Rect? centerSlice,
    bool matchTextDirection = false,
    bool gaplessPlayback = false,
    bool isAntiAlias = false,
    FilterQuality filterQuality = FilterQuality.low,
  }) {
    return Image(
      key: key,
      image: image,
      frameBuilder: frameBuilder,
      loadingBuilder: loadingBuilder,
      errorBuilder: errorBuilder,
      semanticLabel: semanticLabel,
      excludeFromSemantics: excludeFromSemantics,
      width: width,
      height: height,
      color: color,
      opacity: opacity,
      colorBlendMode: colorBlendMode,
      fit: fit,
      alignment: alignment,
      repeat: repeat,
      centerSlice: centerSlice,
      matchTextDirection: matchTextDirection,
      gaplessPlayback: gaplessPlayback,
      isAntiAlias: isAntiAlias,
      filterQuality: filterQuality,
    );
  }

  //add text...
  //Method to create an text
  static Text proText({
    required dynamic data,
    Key? key,
    TextStyle? style,
    StrutStyle? strutStyle,
    TextAlign? textAlign,
    TextDirection? textDirection,
    Locale? locale,
    bool? softWrap,
    TextOverflow? overflow,
    TextScaler? textScaler,
    int? maxLines,
    String? semanticsLabel,
    TextWidthBasis? textWidthBasis,
    TextHeightBehavior? textHeightBehavior,
    Color? selectionColor,
  }) {
    return Text(
      data,
      style: style,
      textAlign: textAlign,
      textDirection: textDirection,
      locale: locale,
      softWrap: softWrap,
      overflow: overflow,
      textScaler: textScaler,
      maxLines: maxLines,
      semanticsLabel: semanticsLabel,
      textWidthBasis: textWidthBasis,
      textHeightBehavior: textHeightBehavior,
      selectionColor: selectionColor,
    );
  }

//add column....
  //Method to create a column
  static Column proColumn({
    Key? key,
    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,
    MainAxisSize mainAxisSize = MainAxisSize.max,
    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,
    TextDirection? textDirection,
    VerticalDirection verticalDirection = VerticalDirection.down,
    TextBaseline? textBaseline,
    List<Widget> children = const [],
  }) {
    return Column(
      key: key,
      mainAxisAlignment: mainAxisAlignment,
      mainAxisSize: mainAxisSize,
      crossAxisAlignment: crossAxisAlignment,
      textDirection: textDirection,
      verticalDirection: verticalDirection,
      textBaseline: textBaseline,
      children: children,
    );
  }

  //add container...
  //Method to create a container
  static Container proContainer({
    Key? key,
    AlignmentGeometry? alignment,
    EdgeInsetsGeometry? padding,
    Color? color,
    Decoration? decoration,
    Decoration? foregroundDecoration,
    double? width,
    double? height,
    BoxConstraints? constraints,
    EdgeInsetsGeometry? margin,
    Matrix4? transform,
    AlignmentGeometry? transformAlignment,
    Widget? child,
    Clip clipBehavior = Clip.none,
  }) {
    return Container(
      alignment: alignment,
      padding: padding,
      color: color,
      decoration: decoration,
      foregroundDecoration: foregroundDecoration,
      width: width,
      height: height,
      constraints: constraints,
      margin: margin,
      transform: transform,
      transformAlignment: transformAlignment,
      clipBehavior: clipBehavior,
      child: child,
    );
  }

    //Method to create an row
  static Row proRow(
      {Key? key,
      MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,
      MainAxisSize mainAxisSize = MainAxisSize.max,
      CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,
      TextDirection? textDirection,
      VerticalDirection verticalDirection = VerticalDirection.down,
      TextBaseline? textBaseline,
      List<Widget> children = const <Widget>[]}) {
    return Row(
      key: key,
      mainAxisAlignment: mainAxisAlignment,
      mainAxisSize: mainAxisSize,
      crossAxisAlignment: crossAxisAlignment,
      textDirection: textDirection,
      verticalDirection: verticalDirection,
      textBaseline: textBaseline,
      children: children,
    );
  }
  static FormBuilderCheckbox proCheckbox(
      {Key? key,
      required String name,
      String? Function(bool?)? validator,
      bool? initialValue,
      InputDecoration decoration = const InputDecoration(
          border: InputBorder.none,
          focusedBorder: InputBorder.none,
          enabledBorder: InputBorder.none,
          errorBorder: InputBorder.none,
          disabledBorder: InputBorder.none),
      void Function(bool?)? onChanged,
      dynamic Function(bool?)? valueTransformer,
      bool enabled = true,
      void Function(bool?)? onSaved,
      AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
      void Function()? onReset,
      FocusNode? focusNode,
      String? restorationId,
      required Widget title,
      Color? activeColor,
      bool autofocus = false,
      Color? checkColor,
      EdgeInsets contentPadding = EdgeInsets.zero,
      VisualDensity? visualDensity,
      ListTileControlAffinity controlAffinity = ListTileControlAffinity.leading,
      Widget? secondary,
      bool selected = false,
      Widget? subtitle,
      bool tristate = false,
      OutlinedBorder? shape,
      BorderSide? side}) {
    return FormBuilderCheckbox(
        key: key,
        name: name,
        validator: validator,
        initialValue: initialValue,
        decoration: decoration,
        onChanged: onChanged,
        valueTransformer: valueTransformer,
        enabled: enabled,
        onSaved: onSaved,
        autovalidateMode: autovalidateMode,
        onReset: onReset,
        focusNode: focusNode,
        restorationId: restorationId,
        title: title,
        activeColor: activeColor,
        autofocus: autofocus,
        checkColor: checkColor,
        contentPadding: contentPadding,
        visualDensity: visualDensity,
        controlAffinity: controlAffinity,
        secondary: secondary,
        selected: selected,
        subtitle: subtitle,
        tristate: tristate,
        shape: shape,
        side: side);
  }


*/

  // Method to create a text.rich
  static Text proTextRich(
      {required InlineSpan textSpan,
      Key? key,
      TextStyle? style,
      StrutStyle? strutStyle,
      TextAlign? textAlign,
      TextDirection? textDirection,
      Locale? locale,
      bool? softWrap,
      TextOverflow? overflow,
      TextScaler? textScaler,
      int? maxLines,
      String? semanticsLabel,
      TextWidthBasis? textWidthBasis,
      TextHeightBehavior? textHeightBehavior,
      Color? selectionColor}) {
    return Text.rich(
      textSpan,
      style: style,
      strutStyle: strutStyle,
      textAlign: textAlign,
      textDirection: textDirection,
      locale: locale,
      softWrap: softWrap,
      overflow: overflow,
      textScaler: textScaler,
      maxLines: maxLines,
      semanticsLabel: semanticsLabel,
      textWidthBasis: textWidthBasis,
      textHeightBehavior: textHeightBehavior,
      selectionColor: selectionColor,
    );
  }

  //add gridview...
  //Method to create a gridview
  /*    static GridView proGridView({
            Key? key,
            Axis scrollDirection = Axis.vertical,
            bool reverse = false,
            ScrollController? controller,
            bool? primary,
            ScrollPhysics? physics,
            bool shrinkWrap = false,
            EdgeInsetsGeometry? padding,
            required SliverGridDelegate gridDelegate,
            bool addAutomaticKeepAlives = true,
            bool addRepaintBoundaries = true,
            bool addSemanticIndexes = true,
            double? cacheExtent,
            List<Widget> children = const <Widget>[],
            int? semanticChildCount,
            Clip clipBehavior = Clip.hardEdge,
            ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual,
            dynamic String,
           }){
               return GridView(
                 gridDelegate: gridDelegate,
                 scrollDirection: scrollDirection,
                 reverse: reverse,
                 controller: controller,
                 primary: primary, 
                 physics: physics,
                 shrinkWrap: shrinkWrap,
                 padding: padding,
                 addAutomaticKeepAlives: addAutomaticKeepAlives,
                 addRepaintBoundaries: addRepaintBoundaries,
                 addSemanticIndexes: addSemanticIndexes,
                 cacheExtent: cacheExtent,
                 semanticChildCount: semanticChildCount,
                 clipBehavior: clipBehavior,
                 keyboardDismissBehavior: keyboardDismissBehavior,
                 children: children,
                );
              }


  //add table material....
  //Method to create an tablematerial
     static Table proTableMaterial({
            required List<List<String>> data,
            required int columnCount,
            Map<int, TableColumnWidth>? columnWidths,
            TableBorder? border,
            TableCellVerticalAlignment defaultVerticalAlignment = TableCellVerticalAlignment.middle,
            TextStyle? headerStyle,
            TextStyle? cellStyle,
            EdgeInsetsGeometry? cellPadding,
            AlignmentGeometry? cellAlignment,
            }){
                return Table(
                     border: border ?? TableBorder.all(),
                   columnWidths: columnWidths,
                   defaultVerticalAlignment: defaultVerticalAlignment,
                   children: List<TableRow>.generate(
                     data.length,
                     (rowIndex) {
                       return TableRow(
                         children: List<Widget>.generate(
                           columnCount,
                           (colIndex) {
                             bool isHeader = rowIndex == 0;
                             return Padding(
                               padding: cellPadding ?? const EdgeInsets.all(8.0),
                               child: Align(
                                 alignment: cellAlignment ?? Alignment.center,
                                 child: Text(
                                   data[rowIndex][colIndex],
                                   style: isHeader ? headerStyle : cellStyle,
                                 ),
                               ),
                             );
                           },
                        ),
                      );
                    },
                  ),
                );
              }  */

  //Method to create a linearprogressindicator
  static LinearProgressIndicator prolinearProgressIndicator({
    Key? key,
    double? value,
    Color? backgroundColor,
    Color? color,
    Animation<Color?>? valueColor,
    double? minHeight,
    String? semanticsLabel,
    String? semanticsValue,
    BorderRadiusGeometry borderRadius = BorderRadius.zero,
  }) {
    return LinearProgressIndicator(
      value: value,
      backgroundColor: backgroundColor,
      color: color,
      valueColor: valueColor,
      minHeight: minHeight,
      semanticsLabel: semanticsLabel,
      semanticsValue: semanticsValue,
      borderRadius: borderRadius,
    );
  }

  //Method to create a bottomsheet
  /*    static BottomSheet proBottomSheet({
           Key? key,
           AnimationController? animationController,
           bool enableDrag = true,
           bool? showDragHandle,
           Color? dragHandleColor,
           Size? dragHandleSize,
           void Function(DragStartDetails)? onDragStart,
           void Function(DragEndDetails, {required bool isClosing})? onDragEnd,
           Color? backgroundColor,
           Color? shadowColor,
           double? elevation,
           ShapeBorder? shape,
           Clip? clipBehavior,
           BoxConstraints? constraints,
           required VoidCallback onClosing,
           required WidgetBuilder builder
         }){
              return BottomSheet(
                key: key,
                animationController: animationController,
                enableDrag: enableDrag,
                showDragHandle: showDragHandle,
                dragHandleColor: dragHandleColor,
                dragHandleSize: dragHandleSize,
                onDragStart: onDragStart,
                onDragEnd: onDragEnd,
                backgroundColor: backgroundColor,
                shadowColor: shadowColor,
                elevation: elevation,
                shape: shape,
                clipBehavior: clipBehavior,
                constraints: constraints,
                onClosing: onClosing,
                builder: builder,
              );
           }


  //Method to create a alertdialog
       static AlertDialog proAlertDialog({
           Key? key,
           Widget? icon,
           EdgeInsetsGeometry? iconPadding,
           Color? iconColor,
           Widget? title,
           EdgeInsetsGeometry? titlePadding,
           TextStyle? titleTextStyle,
           Widget? content,
           EdgeInsetsGeometry? contentPadding,
           TextStyle? contentTextStyle,
           List<Widget>? actions,
           EdgeInsetsGeometry? actionsPadding,
           MainAxisAlignment? actionsAlignment,
           OverflowBarAlignment? actionsOverflowAlignment,
           VerticalDirection? actionsOverflowDirection,
           double? actionsOverflowButtonSpacing,
           EdgeInsetsGeometry? buttonPadding,
           Color? backgroundColor,
           double? elevation,
           Color? shadowColor,
           Color? surfaceTintColor,
           String? semanticLabel,
           EdgeInsets? insetPadding,
           Clip clipBehavior = Clip.none,
           ShapeBorder? shape,
           AlignmentGeometry? alignment,
           bool scrollable = false
          }){
              return AlertDialog(
                key:key,
                icon: icon,
                iconPadding: iconPadding,
                iconColor: iconColor,
                title: title,
                titlePadding: titlePadding,
                titleTextStyle: titleTextStyle,
                content: content,
                contentPadding: contentPadding,
                contentTextStyle: contentTextStyle,
                actions: actions,
                actionsPadding: actionsPadding,
                actionsAlignment: actionsAlignment,
                actionsOverflowAlignment: actionsOverflowAlignment,
                actionsOverflowButtonSpacing: actionsOverflowButtonSpacing,
                buttonPadding: buttonPadding,
                backgroundColor: backgroundColor,
                elevation: elevation,
                shadowColor:  shadowColor,
                surfaceTintColor: surfaceTintColor,
                semanticLabel: semanticLabel,
                insetPadding: insetPadding,
                clipBehavior: clipBehavior,
                shape: shape,
                alignment: alignment,
                scrollable: scrollable,
              );
            }


  //Method to create a divider
       static Divider proDivider({
           Key? key,
           double? height,
           double? thickness,
           double? indent,
           double? endIndent,
           Color? color,
          }){
               return Divider(
                 key: key,
                 height: height,
                 thickness: thickness,
                 indent: indent,
                 endIndent: endIndent,
                 color: color,
               );
            } 


  //Method to create an list
      static ListView proListView({
          Key? key,
          Axis scrollDirection = Axis.vertical,
          bool reverse = false,
          ScrollController? controller,
          bool? primary,
          ScrollPhysics? physics,
          bool shrinkWrap = false,
          EdgeInsetsGeometry? padding,
          double? itemExtent,
          required itemExtentBuilder,
          Widget? prototypeItem,
          bool addAutomaticKeepAlives = true,
          bool addRepaintBoundaries = true,
          bool addSemanticIndexes = true,
          double? cacheExtent,
          List<Widget> children = const <Widget>[],
          int? semanticChildCount,
          dynamic dragStartBehavior,
          ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual,
          String? restorationId,
          Clip clipBehavior = Clip.hardEdge, required ListTile Function(dynamic context, dynamic index) itemBuilder, required int itemCount,
          }){ 
               return ListView(
                key:key,
                scrollDirection: scrollDirection,
                reverse: reverse,
                controller: controller,
                primary: primary,
                shrinkWrap: shrinkWrap,
                physics: physics,
                padding: padding,
                itemExtent: itemExtent,
                itemExtentBuilder: itemExtentBuilder,
                prototypeItem: prototypeItem,
                addAutomaticKeepAlives: addAutomaticKeepAlives,
                addRepaintBoundaries: addRepaintBoundaries,
                addSemanticIndexes: addSemanticIndexes,
                cacheExtent: cacheExtent,
                semanticChildCount: semanticChildCount,
                dragStartBehavior: dragStartBehavior,
                keyboardDismissBehavior: keyboardDismissBehavior,
                restorationId: restorationId,
                clipBehavior: clipBehavior,
                children: children,
                );
             }


  //Method to create an listtile
      static ListTile proListTile({
           Key? key,
           Widget? leading,
           Widget? title,
           Widget? subtitle,
           Widget? trailing,
           bool isThreeLine = false,
           bool? dense,
           VisualDensity? visualDensity,
           ShapeBorder? shape,
           ListTileStyle? style,
           Color? selectedColor,
           Color? iconColor,
           Color? textColor,
           TextStyle? titleTextStyle,
           TextStyle? subtitleTextStyle,
           TextStyle? leadingAndTrailingTextStyle,
           EdgeInsetsGeometry? contentPadding,
           bool enabled = true,
           GestureTapCallback? onTap,
           GestureLongPressCallback? onLongPress,
           ValueChanged<bool>? onFocusChange,
           MouseCursor? mouseCursor,
           bool selected = false,
           Color? focusColor,
           Color? hoverColor,
           Color? splashColor,
           FocusNode? focusNode,
           bool autofocus = false,
           Color? tileColor,
           Color? selectedTileColor,
           bool? enableFeedback,
           double? horizontalTitleGap,
           double? minVerticalPadding,
           double? minLeadingWidth,
           double? minTileHeight,
           ListTileTitleAlignment? titleAlignment
          }){ 
               return ListTile(
                key: key,
                leading: leading,
                title: title,
                subtitle: subtitle,
                trailing: trailing,
                isThreeLine: isThreeLine,
                dense: dense,
                visualDensity: visualDensity,
                shape: shape,
                style: style,
                selectedColor: selectedColor,
                iconColor: iconColor,
                textColor: textColor,
                titleTextStyle: titleTextStyle,
                subtitleTextStyle: subtitleTextStyle,
                leadingAndTrailingTextStyle: leadingAndTrailingTextStyle,
                contentPadding: contentPadding,
                enabled: enabled,
                onTap: onTap,
                onLongPress: onLongPress,
                onFocusChange: onFocusChange,
                mouseCursor: mouseCursor,
                selected: selected,
                focusColor: focusColor,
                hoverColor: hoverColor,
                splashColor: splashColor,
                focusNode: focusNode,
                autofocus: autofocus,
                tileColor: tileColor,
                selectedTileColor: selectedTileColor,
                enableFeedback: enableFeedback,
                horizontalTitleGap: horizontalTitleGap,
                minVerticalPadding: minVerticalPadding,
                minLeadingWidth: minLeadingWidth,
                minTileHeight: minTileHeight,
                titleAlignment: titleAlignment,
               );
            }*/

  static Widget _defaultContextMenuBuilder(
    BuildContext context,
    EditableTextState editableTextState,
  ) {
    return AdaptiveTextSelectionToolbar.editableText(
      editableTextState: editableTextState,
    );
  }

//----------------------Form Builder Controls-----------------//

  static FormBuilderChoiceChip<dynamic> proChoiceChip({
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    bool enabled = true,
    FocusNode? focusNode,
    void Function(dynamic)? onSaved,
    String? Function(dynamic)? validator,
    InputDecoration decoration = const InputDecoration(),
    Key? key,
    required String name,
    required List<FormBuilderChipOption<dynamic>> options,
    dynamic initialValue,
    String? restorationId,
    void Function(dynamic)? onChanged,
    dynamic Function(dynamic)? valueTransformer,
    void Function()? onReset,
    WrapAlignment alignment = WrapAlignment.start,
    ShapeBorder avatarBorder = const CircleBorder(),
    Color? backgroundColor,
    WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start,
    Axis direction = Axis.horizontal,
    Color? disabledColor,
    double? elevation,
    EdgeInsets? labelPadding,
    TextStyle? labelStyle,
    MaterialTapTargetSize? materialTapTargetSize,
    EdgeInsets? padding,
    double? pressElevation,
    WrapAlignment runAlignment = WrapAlignment.start,
    double runSpacing = 0.0,
    Color? selectedColor,
    Color? selectedShadowColor,
    Color? shadowColor,
    OutlinedBorder? shape,
    double spacing = 0.0,
    TextDirection? textDirection,
    VerticalDirection verticalDirection = VerticalDirection.down,
    VisualDensity? visualDensity,
  }) {
    return FormBuilderChoiceChip(
      autovalidateMode: autovalidateMode,
      enabled: enabled,
      focusNode: focusNode,
      onSaved: onSaved,
      validator: validator,
      decoration: decoration,
      key: key,
      name: name,
      options: options,
      initialValue: initialValue,
      restorationId: restorationId,
      onChanged: onChanged,
      valueTransformer: valueTransformer,
      onReset: onReset,
      alignment: alignment,
      avatarBorder: avatarBorder,
      backgroundColor: backgroundColor,
      crossAxisAlignment: crossAxisAlignment,
      direction: direction,
      disabledColor: disabledColor,
      elevation: elevation,
      labelPadding: labelPadding,
      labelStyle: labelStyle,
      materialTapTargetSize: materialTapTargetSize,
      padding: padding,
      pressElevation: pressElevation,
      runAlignment: runAlignment,
      runSpacing: runSpacing,
      selectedColor: selectedColor,
      selectedShadowColor: selectedShadowColor,
      shadowColor: shadowColor,
      shape: shape,
      spacing: spacing,
      textDirection: textDirection,
      verticalDirection: verticalDirection,
      visualDensity: visualDensity,
    );
  }

  static FormBuilderDateRangePicker proDateRangePicker({
    Key? key,
    required String name,
    String? Function(DateTimeRange?)? validator,
    DateTimeRange? initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(DateTimeRange?)? onChanged,
    dynamic Function(DateTimeRange?)? valueTransformer,
    bool enabled = true,
    void Function(DateTimeRange?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    required DateTime firstDate,
    required DateTime lastDate,
    DateFormat? format,
    int maxLines = 1,
    bool obscureText = false,
    TextCapitalization textCapitalization = TextCapitalization.none,
    EdgeInsets scrollPadding = const EdgeInsets.all(20.0),
    bool enableInteractiveSelection = true,
    MaxLengthEnforcement? maxLengthEnforcement,
    TextAlign textAlign = TextAlign.start,
    TextAlignVertical? textAlignVertical,
    bool autofocus = false,
    bool autocorrect = true,
    double cursorWidth = 2.0,
    TextInputType? keyboardType,
    TextStyle? style,
    TextEditingController? controller,
    TextInputAction? textInputAction,
    StrutStyle? strutStyle,
    TextDirection? textDirection,
    int? maxLength,
    void Function()? onEditingComplete,
    void Function(DateTimeRange?)? onFieldSubmitted,
    List<TextInputFormatter>? inputFormatters,
    Radius? cursorRadius,
    Color? cursorColor,
    Brightness? keyboardAppearance,
    Widget? Function(BuildContext,
            {required int currentLength,
            required bool isFocused,
            required int? maxLength})?
        buildCounter,
    MouseCursor? mouseCursor,
    bool expands = false,
    int? minLines,
    bool showCursor = false,
    Locale? locale,
    String? cancelText,
    String? confirmText,
    DateTime? currentDate,
    String? errorFormatText,
    Widget Function(BuildContext, Widget?)? pickerBuilder,
    String? errorInvalidRangeText,
    String? errorInvalidText,
    String? fieldEndHintText,
    String? fieldEndLabelText,
    String? fieldStartHintText,
    String? fieldStartLabelText,
    String? helpText,
    DatePickerEntryMode initialEntryMode = DatePickerEntryMode.calendar,
    RouteSettings? routeSettings,
    String? saveText,
    bool useRootNavigator = true,
    bool allowClear = false,
    Widget? clearIcon,
  }) {
    return FormBuilderDateRangePicker(
      key: key,
      name: name,
      validator: validator,
      initialValue: initialValue,
      decoration: decoration,
      onChanged: onChanged,
      valueTransformer: valueTransformer,
      enabled: enabled,
      onSaved: onSaved,
      autovalidateMode: autovalidateMode,
      onReset: onReset,
      focusNode: focusNode,
      restorationId: restorationId,
      firstDate: firstDate,
      lastDate: lastDate,
      format: format,
      maxLines: maxLines,
      obscureText: obscureText,
      textCapitalization: textCapitalization,
      scrollPadding: scrollPadding,
      enableInteractiveSelection: enableInteractiveSelection,
      maxLengthEnforcement: maxLengthEnforcement,
      textAlign: textAlign,
      textAlignVertical: textAlignVertical,
      autofocus: autofocus,
      autocorrect: autocorrect,
      cursorWidth: cursorWidth,
      keyboardType: keyboardType,
      style: style,
      controller: controller,
      textInputAction: textInputAction,
      strutStyle: strutStyle,
      textDirection: textDirection,
      maxLength: maxLength,
      onEditingComplete: onEditingComplete,
      onFieldSubmitted: onFieldSubmitted,
      inputFormatters: inputFormatters,
      cursorRadius: cursorRadius,
      cursorColor: cursorColor,
      keyboardAppearance: keyboardAppearance,
      buildCounter: buildCounter,
      mouseCursor: mouseCursor,
      expands: expands,
      minLines: minLines,
      showCursor: showCursor,
      locale: locale,
      cancelText: cancelText,
      confirmText: confirmText,
      currentDate: currentDate,
      errorFormatText: errorFormatText,
      pickerBuilder: pickerBuilder,
      errorInvalidRangeText: errorInvalidRangeText,
      errorInvalidText: errorInvalidText,
      fieldEndHintText: fieldEndHintText,
      fieldEndLabelText: fieldEndLabelText,
      fieldStartHintText: fieldStartHintText,
      fieldStartLabelText: fieldStartLabelText,
      helpText: helpText,
      initialEntryMode: initialEntryMode,
      routeSettings: routeSettings,
      saveText: saveText,
      useRootNavigator: useRootNavigator,
      allowClear: allowClear,
      clearIcon: clearIcon,
    );
  }

  static FormBuilderDateTimePicker proDateTimePicker({
    Key? key,
    required String name,
    String? Function(DateTime?)? validator,
    DateTime? initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(DateTime?)? onChanged,
    dynamic Function(DateTime?)? valueTransformer,
    bool enabled = true,
    void Function(DateTime?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    InputType inputType = InputType.both,
    EdgeInsets scrollPadding = const EdgeInsets.all(20.0),
    double cursorWidth = 2.0,
    bool enableInteractiveSelection = true,
    Widget? resetIcon = const Icon(Icons.close),
    TimeOfDay initialTime = const TimeOfDay(hour: 12, minute: 0),
    TextInputType? keyboardType,
    TextAlign textAlign = TextAlign.start,
    bool autofocus = false,
    bool obscureText = false,
    bool autocorrect = true,
    int? maxLines = 1,
    bool expands = false,
    DatePickerMode initialDatePickerMode = DatePickerMode.day,
    Widget Function(BuildContext, Widget?)? transitionBuilder,
    TextCapitalization textCapitalization = TextCapitalization.none,
    bool useRootNavigator = true,
    DatePickerEntryMode initialEntryMode = DatePickerEntryMode.calendar,
    TimePickerEntryMode timePickerInitialEntryMode = TimePickerEntryMode.dial,
    DateFormat? format,
    DateTime? initialDate,
    DateTime? firstDate,
    DateTime? lastDate,
    DateTime? currentDate,
    Locale? locale,
    int? maxLength,
    TextDirection? textDirection,
    TextAlignVertical? textAlignVertical,
    void Function(DateTime?)? onFieldSubmitted,
    TextEditingController? controller,
    TextStyle? style,
    MaxLengthEnforcement maxLengthEnforcement = MaxLengthEnforcement.none,
    List<TextInputFormatter>? inputFormatters,
    bool showCursor = false,
    int? minLines,
    TextInputAction? textInputAction,
    void Function()? onEditingComplete,
    Widget? Function(BuildContext,
            {required int currentLength,
            required bool isFocused,
            required int? maxLength})?
        buildCounter,
    MouseCursor? mouseCursor,
    Radius? cursorRadius,
    Color? cursorColor,
    Brightness? keyboardAppearance,
    String? cancelText,
    String? confirmText,
    String? errorFormatText,
    String? errorInvalidText,
    String? fieldHintText,
    String? fieldLabelText,
    String? helpText,
    RouteSettings? routeSettings,
    StrutStyle? strutStyle,
    bool Function(DateTime)? selectableDayPredicate,
    Offset? anchorPoint,
    void Function(TimePickerEntryMode)? onEntryModeChanged,
  }) {
    return FormBuilderDateTimePicker(
      key: key,
      name: name,
      validator: validator,
      initialValue: initialValue,
      decoration: decoration,
      onChanged: onChanged,
      valueTransformer: valueTransformer,
      enabled: enabled,
      onSaved: onSaved,
      autovalidateMode: autovalidateMode,
      onReset: onReset,
      focusNode: focusNode,
      restorationId: restorationId,
      inputType: inputType,
      scrollPadding: scrollPadding,
      cursorWidth: cursorWidth,
      enableInteractiveSelection: enableInteractiveSelection,
      resetIcon: resetIcon,
      initialTime: initialTime,
      keyboardType: keyboardType,
      textAlign: textAlign,
      autofocus: autofocus,
      obscureText: obscureText,
      autocorrect: autocorrect,
      maxLines: maxLines,
      expands: expands,
      initialDatePickerMode: initialDatePickerMode,
      transitionBuilder: transitionBuilder,
      textCapitalization: textCapitalization,
      useRootNavigator: useRootNavigator,
      initialEntryMode: initialEntryMode,
      timePickerInitialEntryMode: timePickerInitialEntryMode,
      format: format,
      initialDate: initialDate,
      firstDate: firstDate,
      lastDate: lastDate,
      currentDate: currentDate,
      locale: locale,
      maxLength: maxLength,
      textDirection: textDirection,
      textAlignVertical: textAlignVertical,
      onFieldSubmitted: onFieldSubmitted,
      controller: controller,
      style: style,
      maxLengthEnforcement: maxLengthEnforcement,
      inputFormatters: inputFormatters,
      showCursor: showCursor,
      minLines: minLines,
      textInputAction: textInputAction,
      onEditingComplete: onEditingComplete,
      buildCounter: buildCounter,
      mouseCursor: mouseCursor,
      cursorRadius: cursorRadius,
      cursorColor: cursorColor,
      keyboardAppearance: keyboardAppearance,
      cancelText: cancelText,
      confirmText: confirmText,
      errorFormatText: errorFormatText,
      errorInvalidText: errorInvalidText,
      fieldHintText: fieldHintText,
      fieldLabelText: fieldLabelText,
      helpText: helpText,
      routeSettings: routeSettings,
      strutStyle: strutStyle,
      selectableDayPredicate: selectableDayPredicate,
      anchorPoint: anchorPoint,
      onEntryModeChanged: onEntryModeChanged,
    );
  }

  static FormBuilderDropdown<T> proDropdown<T>({
    Key? key,
    required String name,
    String? Function(T?)? validator,
    T? initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(T?)? onChanged,
    dynamic Function(T?)? valueTransformer,
    bool enabled = true,
    void Function(T?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    required List<DropdownMenuItem<T>> items,
    bool isExpanded = true,
    bool isDense = true,
    int elevation = 8,
    double iconSize = 24.0,
    TextStyle? style,
    Widget? disabledHint,
    Widget? icon,
    Color? iconDisabledColor,
    Color? iconEnabledColor,
    void Function()? onTap,
    bool autofocus = false,
    Color? dropdownColor,
    Color? focusColor,
    double? itemHeight,
    List<Widget> Function(BuildContext)? selectedItemBuilder,
    double? menuMaxHeight,
    bool? enableFeedback,
    BorderRadius? borderRadius,
    AlignmentGeometry alignment = AlignmentDirectional.centerStart,
  }) {
    return FormBuilderDropdown<T>(
      key: key,
      name: name,
      validator: validator,
      initialValue: initialValue,
      decoration: decoration,
      onChanged: onChanged,
      valueTransformer: valueTransformer,
      enabled: enabled,
      onSaved: onSaved,
      autovalidateMode: autovalidateMode,
      onReset: onReset,
      focusNode: focusNode,
      restorationId: restorationId,
      items: items,
      isExpanded: isExpanded,
      isDense: isDense,
      elevation: elevation,
      iconSize: iconSize,
      style: style,
      disabledHint: disabledHint,
      icon: icon,
      iconDisabledColor: iconDisabledColor,
      iconEnabledColor: iconDisabledColor,
      onTap: onTap,
      autofocus: autofocus,
      dropdownColor: dropdownColor,
      focusColor: focusColor,
      itemHeight: itemHeight,
      selectedItemBuilder: selectedItemBuilder,
      menuMaxHeight: menuMaxHeight,
      enableFeedback: enableFeedback,
      borderRadius: borderRadius,
      alignment: alignment,
    );
  }

  static FormBuilderFilterChip proFilterChip({
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    bool enabled = true,
    FocusNode? focusNode,
    void Function(List<dynamic>?)? onSaved,
    String? Function(List<dynamic>?)? validator,
    InputDecoration decoration = const InputDecoration(),
    Key? key,
    List<dynamic>? initialValue,
    required String name,
    String? restorationId,
    required List<FormBuilderChipOption<dynamic>> options,
    WrapAlignment alignment = WrapAlignment.start,
    ShapeBorder avatarBorder = const CircleBorder(),
    Color? backgroundColor,
    Color? checkmarkColor,
    Clip clipBehavior = Clip.none,
    WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start,
    Axis direction = Axis.horizontal,
    Color? disabledColor,
    double? elevation,
    EdgeInsets? labelPadding,
    TextStyle? labelStyle,
    MaterialTapTargetSize? materialTapTargetSize,
    int? maxChips,
    EdgeInsets? padding,
    double? pressElevation,
    WrapAlignment runAlignment = WrapAlignment.start,
    double runSpacing = 0.0,
    Color? selectedColor,
    Color? selectedShadowColor,
    Color? shadowColor,
    OutlinedBorder? shape,
    bool showCheckmark = true,
    double spacing = 0.0,
    TextDirection? textDirection,
    VerticalDirection verticalDirection = VerticalDirection.down,
    void Function(List<dynamic>?)? onChanged,
    dynamic Function(List<dynamic>?)? valueTransformer,
    void Function()? onReset,
  }) {
    return FormBuilderFilterChip(
      autovalidateMode: autovalidateMode,
      enabled: enabled,
      focusNode: focusNode,
      onSaved: onSaved,
      validator: validator,
      decoration: decoration,
      key: key,
      initialValue: initialValue,
      name: name,
      restorationId: restorationId,
      options: options,
      alignment: alignment,
      avatarBorder: avatarBorder,
      backgroundColor: backgroundColor,
      checkmarkColor: checkmarkColor,
      clipBehavior: clipBehavior,
      crossAxisAlignment: crossAxisAlignment,
      direction: direction,
      disabledColor: disabledColor,
      elevation: elevation,
      labelPadding: labelPadding,
      labelStyle: labelStyle,
      materialTapTargetSize: materialTapTargetSize,
      maxChips: maxChips,
      padding: padding,
      pressElevation: pressElevation,
      runAlignment: runAlignment,
      runSpacing: runSpacing,
      selectedColor: selectedColor,
      selectedShadowColor: selectedShadowColor,
      shadowColor: shadowColor,
      shape: shape,
      showCheckmark: showCheckmark,
      spacing: spacing,
      textDirection: textDirection,
      verticalDirection: verticalDirection,
      onChanged: onChanged,
      valueTransformer: valueTransformer,
      onReset: onReset,
    );
  }

  static FormBuilderRadioGroup<T> proRadioGroup<T>({
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    bool enabled = true,
    FocusNode? focusNode,
    void Function(T?)? onSaved,
    String? Function(T?)? validator,
    InputDecoration decoration = const InputDecoration(),
    Key? key,
    required String name,
    required List<FormBuilderFieldOption<T>> options,
    T? initialValue,
    Color? activeColor,
    ControlAffinity controlAffinity = ControlAffinity.leading,
    List<T>? disabled,
    Color? focusColor,
    Color? hoverColor,
    MaterialTapTargetSize? materialTapTargetSize,
    OptionsOrientation orientation = OptionsOrientation.wrap,
    Widget? separator,
    WrapAlignment wrapAlignment = WrapAlignment.start,
    WrapCrossAlignment wrapCrossAxisAlignment = WrapCrossAlignment.start,
    Axis wrapDirection = Axis.horizontal,
    WrapAlignment wrapRunAlignment = WrapAlignment.start,
    double wrapRunSpacing = 0.0,
    double wrapSpacing = 0.0,
    TextDirection? wrapTextDirection,
    VerticalDirection wrapVerticalDirection = VerticalDirection.down,
    void Function(T?)? onChanged,
    dynamic Function(T?)? valueTransformer,
    void Function()? onReset,
    String? restorationId,
    BoxDecoration? itemDecoration,
  }) {
    return FormBuilderRadioGroup<T>(
        autovalidateMode: autovalidateMode,
        enabled: enabled,
        focusNode: focusNode,
        onSaved: onSaved,
        validator: validator,
        decoration: decoration,
        key: key,
        name: name,
        options: options,
        initialValue: initialValue,
        activeColor: activeColor,
        controlAffinity: controlAffinity,
        disabled: disabled,
        focusColor: focusColor,
        hoverColor: hoverColor,
        materialTapTargetSize: materialTapTargetSize,
        orientation: orientation,
        separator: separator,
        wrapAlignment: wrapAlignment,
        wrapCrossAxisAlignment: wrapCrossAxisAlignment,
        wrapDirection: wrapDirection,
        wrapRunAlignment: wrapRunAlignment,
        wrapRunSpacing: wrapRunSpacing,
        wrapSpacing: wrapSpacing,
        wrapTextDirection: wrapTextDirection,
        wrapVerticalDirection: wrapVerticalDirection,
        onChanged: onChanged,
        valueTransformer: valueTransformer,
        onReset: onReset,
        restorationId: restorationId,
        itemDecoration: itemDecoration);
  }

  static FormBuilderRangeSlider proRangeSlider({
    Key? key,
    required String name,
    String? Function(RangeValues?)? validator,
    RangeValues? initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(RangeValues?)? onChanged,
    dynamic Function(RangeValues?)? valueTransformer,
    bool enabled = true,
    void Function(RangeValues?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    required double min,
    required double max,
    int? divisions,
    Color? activeColor,
    Color? inactiveColor,
    void Function(RangeValues)? onChangeStart,
    void Function(RangeValues)? onChangeEnd,
    RangeLabels? labels,
    String Function(double)? semanticFormatterCallback,
    DisplayValues displayValues = DisplayValues.all,
    Widget Function(String)? minValueWidget,
    Widget Function(String)? valueWidget,
    Widget Function(String)? maxValueWidget,
    NumberFormat? numberFormat,
  }) {
    return FormBuilderRangeSlider(
      key: key,
      name: name,
      validator: validator,
      initialValue: initialValue,
      decoration: decoration,
      onChanged: onChanged,
      valueTransformer: valueTransformer,
      enabled: enabled,
      onSaved: onSaved,
      autovalidateMode: autovalidateMode,
      onReset: onReset,
      focusNode: focusNode,
      min: min,
      max: max,
      divisions: divisions,
      activeColor: activeColor,
      inactiveColor: inactiveColor,
      onChangeStart: onChangeStart,
      onChangeEnd: onChangeEnd,
      labels: labels,
      semanticFormatterCallback: semanticFormatterCallback,
      displayValues: displayValues,
      minValueWidget: minValueWidget,
      valueWidget: valueWidget,
      maxValueWidget: maxValueWidget,
      numberFormat: numberFormat,
    );
  }

  static FormBuilderSlider proSlider({
    Key? key,
    required String name,
    String? Function(double?)? validator,
    required double initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(double?)? onChanged,
    dynamic Function(double?)? valueTransformer,
    bool enabled = true,
    void Function(double?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    required double min,
    required double max,
    int? divisions,
    Color? activeColor,
    Color? inactiveColor,
    void Function(double)? onChangeStart,
    void Function(double)? onChangeEnd,
    String? label,
    String Function(double)? semanticFormatterCallback,
    NumberFormat? numberFormat,
    DisplayValues displayValues = DisplayValues.all,
    bool autofocus = false,
    MouseCursor? mouseCursor,
    Widget Function(String)? maxValueWidget,
    Widget Function(String)? minValueWidget,
    Widget Function(String)? valueWidget,
  }) {
    return FormBuilderSlider(
      key: key,
      name: name,
      validator: validator,
      initialValue: initialValue,
      decoration: decoration,
      onChanged: onChanged,
      valueTransformer: valueTransformer,
      enabled: enabled,
      onSaved: onSaved,
      autovalidateMode: autovalidateMode,
      onReset: onReset,
      focusNode: focusNode,
      restorationId: restorationId,
      min: min,
      max: max,
      divisions: divisions,
      activeColor: activeColor,
      inactiveColor: inactiveColor,
      onChangeStart: onChangeStart,
      onChangeEnd: onChangeEnd,
      label: label,
      semanticFormatterCallback: semanticFormatterCallback,
      numberFormat: numberFormat,
      displayValues: displayValues,
      autofocus: autofocus,
      mouseCursor: mouseCursor,
      maxValueWidget: maxValueWidget,
      minValueWidget: minValueWidget,
      valueWidget: valueWidget,
    );
  }

  static FormBuilderSwitch proSwitch({
    Key? key,
    required String name,
    String? Function(bool?)? validator,
    bool? initialValue,
    InputDecoration decoration = const InputDecoration(),
    void Function(bool?)? onChanged,
    dynamic Function(bool?)? valueTransformer,
    bool enabled = true,
    void Function(bool?)? onSaved,
    AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
    void Function()? onReset,
    FocusNode? focusNode,
    String? restorationId,
    required Widget title,
    Color? activeColor,
    Color? activeTrackColor,
    Color? inactiveThumbColor,
    Color? inactiveTrackColor,
    ImageProvider<Object>? activeThumbImage,
    ImageProvider<Object>? inactiveThumbImage,
    Widget? subtitle,
    Widget? secondary,
    ListTileControlAffinity controlAffinity = ListTileControlAffinity.trailing,
    EdgeInsets contentPadding = EdgeInsets.zero,
    bool autofocus = false,
    bool selected = false,
  }) {
    return FormBuilderSwitch(
      key: key,
      name: name,
      validator: validator,
      initialValue: initialValue,
      decoration: decoration,
      onChanged: onChanged,
      valueTransformer: valueTransformer,
      enabled: enabled,
      onSaved: onSaved,
      autovalidateMode: autovalidateMode,
      onReset: onReset,
      focusNode: focusNode,
      restorationId: restorationId,
      title: title,
      activeColor: activeColor,
      activeTrackColor: activeTrackColor,
      inactiveTrackColor: inactiveTrackColor,
      activeThumbImage: activeThumbImage,
      inactiveThumbImage: inactiveThumbImage,
      subtitle: subtitle,
      secondary: secondary,
      controlAffinity: controlAffinity,
      contentPadding: contentPadding,
      autofocus: autofocus,
      selected: selected,
    );
  }

  static FormBuilderTextField proTextField(
      {Key? key,
      required String name,
      String? Function(String?)? validator,
      InputDecoration decoration = const InputDecoration(),
      void Function(String?)? onChanged,
      dynamic Function(String?)? valueTransformer,
      bool enabled = true,
      void Function(String?)? onSaved,
      AutovalidateMode? autovalidateMode = AutovalidateMode.disabled,
      void Function()? onReset,
      FocusNode? focusNode,
      String? restorationId,
      String? initialValue,
      bool readOnly = false,
      int? maxLines = 1,
      bool obscureText = false,
      TextCapitalization textCapitalization = TextCapitalization.none,
      EdgeInsets scrollPadding = const EdgeInsets.all(20.0),
      bool enableInteractiveSelection = true,
      MaxLengthEnforcement? maxLengthEnforcement,
      TextAlign textAlign = TextAlign.start,
      bool autofocus = false,
      bool autocorrect = true,
      double cursorWidth = 2.0,
      double? cursorHeight,
      TextInputType? keyboardType,
      TextStyle? style,
      TextEditingController? controller,
      TextInputAction? textInputAction,
      StrutStyle? strutStyle,
      TextDirection? textDirection,
      int? maxLength,
      void Function()? onEditingComplete,
      void Function(String?)? onSubmitted,
      List<TextInputFormatter>? inputFormatters,
      Radius? cursorRadius,
      Color? cursorColor,
      Brightness? keyboardAppearance,
      Widget? Function(BuildContext,
              {required int currentLength,
              required bool isFocused,
              required int? maxLength})?
          buildCounter,
      bool expands = false,
      int? minLines,
      bool? showCursor,
      void Function()? onTap,
      void Function(PointerDownEvent)? onTapOutside,
      bool enableSuggestions = false,
      TextAlignVertical? textAlignVertical,
      DragStartBehavior dragStartBehavior = DragStartBehavior.start,
      ScrollController? scrollController,
      ScrollPhysics? scrollPhysics,
      BoxWidthStyle selectionWidthStyle = BoxWidthStyle.tight,
      SmartDashesType? smartDashesType,
      SmartQuotesType? smartQuotesType,
      BoxHeightStyle selectionHeightStyle = BoxHeightStyle.tight,
      Iterable<String>? autofillHints,
      String obscuringCharacter = '•',
      MouseCursor? mouseCursor,
      Widget Function(BuildContext, EditableTextState)? contextMenuBuilder =
          _defaultContextMenuBuilder,
      TextMagnifierConfiguration? magnifierConfiguration,
      ContentInsertionConfiguration? contentInsertionConfiguration,
      SpellCheckConfiguration? spellCheckConfiguration}) {
    return FormBuilderTextField(
        key: key,
        name: name,
        validator: validator,
        decoration: decoration,
        onChanged: onChanged,
        valueTransformer: valueTransformer,
        enabled: enabled,
        onSaved: onSaved,
        autovalidateMode: autovalidateMode,
        onReset: onReset,
        focusNode: focusNode,
        restorationId: restorationId,
        initialValue: initialValue,
        readOnly: readOnly,
        maxLines: maxLines,
        obscureText: obscureText,
        textCapitalization: textCapitalization,
        scrollPadding: scrollPadding,
        enableInteractiveSelection: enableInteractiveSelection,
        maxLengthEnforcement: maxLengthEnforcement,
        textAlign: textAlign,
        autofocus: autofocus,
        autocorrect: autocorrect,
        cursorWidth: cursorWidth,
        cursorHeight: cursorHeight,
        keyboardType: keyboardType,
        style: style,
        controller: controller,
        textInputAction: textInputAction,
        strutStyle: strutStyle,
        textDirection: textDirection,
        maxLength: maxLength,
        onEditingComplete: onEditingComplete,
        onSubmitted: onSubmitted,
        inputFormatters: inputFormatters,
        cursorRadius: cursorRadius,
        cursorColor: cursorColor,
        keyboardAppearance: keyboardAppearance,
        buildCounter: buildCounter,
        expands: expands,
        minLines: minLines,
        showCursor: showCursor,
        onTap: onTap,
        onTapOutside: onTapOutside,
        enableSuggestions: enableSuggestions,
        textAlignVertical: textAlignVertical,
        dragStartBehavior: dragStartBehavior,
        scrollController: scrollController,
        scrollPhysics: scrollPhysics,
        selectionWidthStyle: selectionWidthStyle,
        smartDashesType: smartDashesType,
        smartQuotesType: smartQuotesType,
        selectionHeightStyle: selectionHeightStyle,
        autofillHints: autofillHints,
        obscuringCharacter: obscuringCharacter,
        mouseCursor: mouseCursor,
        contextMenuBuilder: contextMenuBuilder,
        magnifierConfiguration: magnifierConfiguration,
        contentInsertionConfiguration: contentInsertionConfiguration,
        spellCheckConfiguration: spellCheckConfiguration);
  }


*/
